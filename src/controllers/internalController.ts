/**
 * bandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

import { ApiResponse } from '../apiResponse';
import { ApiError } from '../errors/apiError';
import { RequestOptions } from '../http/requestBuilder';
import { A2pCampaignId, a2pCampaignIdSchema } from '../models/a2pCampaignId';
import { A2pClass, a2pClassSchema } from '../models/a2pClass';
import {
  AccountHttpFeature,
  accountHttpFeatureSchema,
} from '../models/accountHttpFeature';
import {
  AccountHttpFeatureResponse,
  accountHttpFeatureResponseSchema,
} from '../models/accountHttpFeatureResponse';
import {
  AccountMessagingRoutesResponse,
  accountMessagingRoutesResponseSchema,
} from '../models/accountMessagingRoutesResponse';
import {
  AccountMmsFeature,
  accountMmsFeatureSchema,
} from '../models/accountMmsFeature';
import {
  AccountMmsFeatureResponse,
  accountMmsFeatureResponseSchema,
} from '../models/accountMmsFeatureResponse';
import { AccountProduct, accountProductSchema } from '../models/accountProduct';
import {
  AccountProductResponse,
  accountProductResponseSchema,
} from '../models/accountProductResponse';
import {
  AccountSearchResponse,
  accountSearchResponseSchema,
} from '../models/accountSearchResponse';
import {
  AccountSitesHostsResponse,
  accountSitesHostsResponseSchema,
} from '../models/accountSitesHostsResponse';
import {
  AccountSmsFeature,
  accountSmsFeatureSchema,
} from '../models/accountSmsFeature';
import {
  AccountSmsFeatureResponse,
  accountSmsFeatureResponseSchema,
} from '../models/accountSmsFeatureResponse';
import {
  AccountsResponse,
  accountsResponseSchema,
} from '../models/accountsResponse';
import {
  AccountTerminationConfigurationPayload,
  accountTerminationConfigurationPayloadSchema,
} from '../models/accountTerminationConfigurationPayload';
import {
  AccountTerminationConfigurationResponse,
  accountTerminationConfigurationResponseSchema,
} from '../models/accountTerminationConfigurationResponse';
import {
  AccountTollFreeTotalsResponse,
  accountTollFreeTotalsResponseSchema,
} from '../models/accountTollFreeTotalsResponse';
import {
  AdminDataResponse,
  adminDataResponseSchema,
} from '../models/adminDataResponse';
import {
  BillingSettings,
  billingSettingsSchema,
} from '../models/billingSettings';
import {
  BillingSettingsResponse,
  billingSettingsResponseSchema,
} from '../models/billingSettingsResponse';
import { BocAccountList, bocAccountListSchema } from '../models/bocAccountList';
import {
  BreakOutCountry,
  breakOutCountrySchema,
} from '../models/breakOutCountry';
import {
  CarrierMaskFileResponse,
  carrierMaskFileResponseSchema,
} from '../models/carrierMaskFileResponse';
import { Country, countrySchema } from '../models/country';
import { DeckTypeEnum, deckTypeEnumSchema } from '../models/deckTypeEnum';
import { E911Settings, e911SettingsSchema } from '../models/e911Settings';
import {
  E911SettingsResponse,
  e911SettingsResponseSchema,
} from '../models/e911SettingsResponse';
import {
  EdgeManagementConfigurationPayload,
  edgeManagementConfigurationPayloadSchema,
} from '../models/edgeManagementConfigurationPayload';
import {
  EdgeManagementConfigurationResponse,
  edgeManagementConfigurationResponseSchema,
} from '../models/edgeManagementConfigurationResponse';
import {
  FileListResponse,
  fileListResponseSchema,
} from '../models/fileListResponse';
import { FiletypeEnum, filetypeEnumSchema } from '../models/filetypeEnum';
import {
  GanProfileAttributeMigration,
  ganProfileAttributeMigrationSchema,
} from '../models/ganProfileAttributeMigration';
import { HolidayPayload, holidayPayloadSchema } from '../models/holidayPayload';
import {
  HolidayResponse,
  holidayResponseSchema,
} from '../models/holidayResponse';
import {
  ImportAvailableNumberOrder,
  importAvailableNumberOrderSchema,
} from '../models/importAvailableNumberOrder';
import {
  InternalPortEvent,
  internalPortEventSchema,
} from '../models/internalPortEvent';
import {
  InternationalVendor,
  internationalVendorSchema,
} from '../models/internationalVendor';
import { LdapPermission, ldapPermissionSchema } from '../models/ldapPermission';
import {
  LdapPermissionResponse,
  ldapPermissionResponseSchema,
} from '../models/ldapPermissionResponse';
import {
  LdapUserPreferencesResponse,
  ldapUserPreferencesResponseSchema,
} from '../models/ldapUserPreferencesResponse';
import {
  LdapUserResponse,
  ldapUserResponseSchema,
} from '../models/ldapUserResponse';
import {
  Level3PortingErrorSettingPayload,
  level3PortingErrorSettingPayloadSchema,
} from '../models/level3PortingErrorSettingPayload';
import {
  LidbOrderPayload,
  lidbOrderPayloadSchema,
} from '../models/lidbOrderPayload';
import {
  LidbOrderResponse,
  lidbOrderResponseSchema,
} from '../models/lidbOrderResponse';
import {
  MessagingBlockedAccountId,
  messagingBlockedAccountIdSchema,
} from '../models/messagingBlockedAccountId';
import {
  MessagingRoutes,
  messagingRoutesSchema,
} from '../models/messagingRoutes';
import {
  MessagingSettings,
  messagingSettingsSchema,
} from '../models/messagingSettings';
import {
  MessagingSettingsResponse,
  messagingSettingsResponseSchema,
} from '../models/messagingSettingsResponse';
import { Mm4Settings, mm4SettingsSchema } from '../models/mm4Settings';
import {
  MmsFeatureMm4SettingsResponse,
  mmsFeatureMm4SettingsResponseSchema,
} from '../models/mmsFeatureMm4SettingsResponse';
import {
  NnidAccountSync,
  nnidAccountSyncSchema,
} from '../models/nnidAccountSync';
import { NnRoute, nnRouteSchema } from '../models/nnRoute';
import {
  NumberManagementSettings,
  numberManagementSettingsSchema,
} from '../models/numberManagementSettings';
import {
  OriginationConfigurationPayload,
  originationConfigurationPayloadSchema,
} from '../models/originationConfigurationPayload';
import {
  OriginationConfigurationResponse,
  originationConfigurationResponseSchema,
} from '../models/originationConfigurationResponse';
import { OriginEnum, originEnumSchema } from '../models/originEnum';
import { PomAccount, pomAccountSchema } from '../models/pomAccount';
import {
  PomAccountResponse,
  pomAccountResponseSchema,
} from '../models/pomAccountResponse';
import {
  ProductResponse,
  productResponseSchema,
} from '../models/productResponse';
import {
  ProductsResponse,
  productsResponseSchema,
} from '../models/productsResponse';
import { ProxyPeerValue, proxyPeerValueSchema } from '../models/proxyPeerValue';
import {
  RateCenterCoverage,
  rateCenterCoverageSchema,
} from '../models/rateCenterCoverage';
import {
  RegionsResponse,
  regionsResponseSchema,
} from '../models/regionsResponse';
import { Report, reportSchema } from '../models/report';
import { ReportInstance, reportInstanceSchema } from '../models/reportInstance';
import {
  ReportInstanceResponse,
  reportInstanceResponseSchema,
} from '../models/reportInstanceResponse';
import {
  ReportInstancesResponse,
  reportInstancesResponseSchema,
} from '../models/reportInstancesResponse';
import { ReportResponse, reportResponseSchema } from '../models/reportResponse';
import {
  ReportsResponse,
  reportsResponseSchema,
} from '../models/reportsResponse';
import {
  ReservationResponse,
  reservationResponseSchema,
} from '../models/reservationResponse';
import {
  ReservationsResponse,
  reservationsResponseSchema,
} from '../models/reservationsResponse';
import { SbcNodeGroup, sbcNodeGroupSchema } from '../models/sbcNodeGroup';
import { SettingPayload, settingPayloadSchema } from '../models/settingPayload';
import { SipCredentials, sipCredentialsSchema } from '../models/sipCredentials';
import {
  SipPeerEdgeManagementProduct,
  sipPeerEdgeManagementProductSchema,
} from '../models/sipPeerEdgeManagementProduct';
import {
  SipPeerEdgeManagementProductResponse,
  sipPeerEdgeManagementProductResponseSchema,
} from '../models/sipPeerEdgeManagementProductResponse';
import {
  SipPeerGatewayAttributeResponse,
  sipPeerGatewayAttributeResponseSchema,
} from '../models/sipPeerGatewayAttributeResponse';
import {
  SipPeerGatewayIp,
  sipPeerGatewayIpSchema,
} from '../models/sipPeerGatewayIp';
import {
  SipPeerGatewayIpResponse,
  sipPeerGatewayIpResponseSchema,
} from '../models/sipPeerGatewayIpResponse';
import { SiteBillingId, siteBillingIdSchema } from '../models/siteBillingId';
import {
  SiteBillingIdResponse,
  siteBillingIdResponseSchema,
} from '../models/siteBillingIdResponse';
import { SiteContract, siteContractSchema } from '../models/siteContract';
import {
  SiteContractResponse,
  siteContractResponseSchema,
} from '../models/siteContractResponse';
import { SiteLock, siteLockSchema } from '../models/siteLock';
import {
  SiteLockResponse,
  siteLockResponseSchema,
} from '../models/siteLockResponse';
import {
  SiteTnTotalResponse,
  siteTnTotalResponseSchema,
} from '../models/siteTnTotalResponse';
import {
  SiteTollFreeTotalsResponse,
  siteTollFreeTotalsResponseSchema,
} from '../models/siteTollFreeTotalsResponse';
import { SlingshotEnv, slingshotEnvSchema } from '../models/slingshotEnv';
import {
  SystemEventSubscription,
  systemEventSubscriptionSchema,
} from '../models/systemEventSubscription';
import {
  TelephoneNumbers,
  telephoneNumbersSchema,
} from '../models/telephoneNumbers';
import {
  TelephoneNumbersDetailsHistory,
  telephoneNumbersDetailsHistorySchema,
} from '../models/telephoneNumbersDetailsHistory';
import {
  TelephoneNumberTotalsHistory,
  telephoneNumberTotalsHistorySchema,
} from '../models/telephoneNumberTotalsHistory';
import {
  TerminationAccount,
  terminationAccountSchema,
} from '../models/terminationAccount';
import {
  TerminationAccountResponse,
  terminationAccountResponseSchema,
} from '../models/terminationAccountResponse';
import {
  TerminationAttribute,
  terminationAttributeSchema,
} from '../models/terminationAttribute';
import {
  TerminationAttributeMetadata,
  terminationAttributeMetadataSchema,
} from '../models/terminationAttributeMetadata';
import {
  TerminationAttributeMetadataByNameResponse,
  terminationAttributeMetadataByNameResponseSchema,
} from '../models/terminationAttributeMetadataByNameResponse';
import {
  TerminationAttributeMetadataByOriginResponse,
  terminationAttributeMetadataByOriginResponseSchema,
} from '../models/terminationAttributeMetadataByOriginResponse';
import {
  TerminationAttributeMetadataResponse,
  terminationAttributeMetadataResponseSchema,
} from '../models/terminationAttributeMetadataResponse';
import {
  TerminationAttributeMetadatasResponse,
  terminationAttributeMetadatasResponseSchema,
} from '../models/terminationAttributeMetadatasResponse';
import {
  TerminationAttributeResponse,
  terminationAttributeResponseSchema,
} from '../models/terminationAttributeResponse';
import {
  TerminationAttributesResponse,
  terminationAttributesResponseSchema,
} from '../models/terminationAttributesResponse';
import {
  TerminationCarrierMask,
  terminationCarrierMaskSchema,
} from '../models/terminationCarrierMask';
import {
  TerminationCarrierMaskMetadataResponse,
  terminationCarrierMaskMetadataResponseSchema,
} from '../models/terminationCarrierMaskMetadataResponse';
import {
  TerminationCarrierMaskMetadataSearchResponse,
  terminationCarrierMaskMetadataSearchResponseSchema,
} from '../models/terminationCarrierMaskMetadataSearchResponse';
import {
  TerminationCarrierMaskMetadatasResponse,
  terminationCarrierMaskMetadatasResponseSchema,
} from '../models/terminationCarrierMaskMetadatasResponse';
import {
  TerminationCarrierMaskResponse,
  terminationCarrierMaskResponseSchema,
} from '../models/terminationCarrierMaskResponse';
import {
  TerminationCarrierMasksResponse,
  terminationCarrierMasksResponseSchema,
} from '../models/terminationCarrierMasksResponse';
import {
  TerminationCarriersResponse,
  terminationCarriersResponseSchema,
} from '../models/terminationCarriersResponse';
import {
  TerminationCustomerProductAssignmentResponse,
  terminationCustomerProductAssignmentResponseSchema,
} from '../models/terminationCustomerProductAssignmentResponse';
import {
  TerminationCustomerProductAssignmentsResponse,
  terminationCustomerProductAssignmentsResponseSchema,
} from '../models/terminationCustomerProductAssignmentsResponse';
import {
  TerminationGateway,
  terminationGatewaySchema,
} from '../models/terminationGateway';
import {
  TerminationGatewayAttributeResponse,
  terminationGatewayAttributeResponseSchema,
} from '../models/terminationGatewayAttributeResponse';
import {
  TerminationGatewayAttributesResponse,
  terminationGatewayAttributesResponseSchema,
} from '../models/terminationGatewayAttributesResponse';
import {
  TerminationGatewayResponse,
  terminationGatewayResponseSchema,
} from '../models/terminationGatewayResponse';
import {
  TerminationGatewaysResponse,
  terminationGatewaysResponseSchema,
} from '../models/terminationGatewaysResponse';
import {
  TerminationMigrationResponse,
  terminationMigrationResponseSchema,
} from '../models/terminationMigrationResponse';
import {
  TerminationProduct,
  terminationProductSchema,
} from '../models/terminationProduct';
import {
  TerminationProductAssignment,
  terminationProductAssignmentSchema,
} from '../models/terminationProductAssignment';
import {
  TerminationProductAttributeResponse,
  terminationProductAttributeResponseSchema,
} from '../models/terminationProductAttributeResponse';
import {
  TerminationProductAttributesResponse,
  terminationProductAttributesResponseSchema,
} from '../models/terminationProductAttributesResponse';
import {
  TerminationProductResponse,
  terminationProductResponseSchema,
} from '../models/terminationProductResponse';
import {
  TerminationProductsResponse,
  terminationProductsResponseSchema,
} from '../models/terminationProductsResponse';
import {
  TerminationRateDeckAssignment,
  terminationRateDeckAssignmentSchema,
} from '../models/terminationRateDeckAssignment';
import {
  TerminationRateDeckAssignmentResponse,
  terminationRateDeckAssignmentResponseSchema,
} from '../models/terminationRateDeckAssignmentResponse';
import {
  TerminationRateDeckAssignmentsResponse,
  terminationRateDeckAssignmentsResponseSchema,
} from '../models/terminationRateDeckAssignmentsResponse';
import {
  TerminationRateDeckAssignmentsUtilityResponse,
  terminationRateDeckAssignmentsUtilityResponseSchema,
} from '../models/terminationRateDeckAssignmentsUtilityResponse';
import {
  TerminationRateDeckAssignmentUtilityResponse,
  terminationRateDeckAssignmentUtilityResponseSchema,
} from '../models/terminationRateDeckAssignmentUtilityResponse';
import {
  TerminationRateDeckMetadataByTypeResponse,
  terminationRateDeckMetadataByTypeResponseSchema,
} from '../models/terminationRateDeckMetadataByTypeResponse';
import {
  TerminationRateDeckMetadataResponse,
  terminationRateDeckMetadataResponseSchema,
} from '../models/terminationRateDeckMetadataResponse';
import {
  TerminationRateDeckMetadatasResponse,
  terminationRateDeckMetadatasResponseSchema,
} from '../models/terminationRateDeckMetadatasResponse';
import {
  TerminationRateDeckResponse,
  terminationRateDeckResponseSchema,
} from '../models/terminationRateDeckResponse';
import {
  TerminationRoutingException,
  terminationRoutingExceptionSchema,
} from '../models/terminationRoutingException';
import {
  TerminationRoutingExceptionFileResponse,
  terminationRoutingExceptionFileResponseSchema,
} from '../models/terminationRoutingExceptionFileResponse';
import {
  TerminationRoutingExceptionMetadataResponse,
  terminationRoutingExceptionMetadataResponseSchema,
} from '../models/terminationRoutingExceptionMetadataResponse';
import {
  TerminationRoutingExceptionResponse,
  terminationRoutingExceptionResponseSchema,
} from '../models/terminationRoutingExceptionResponse';
import {
  TerminationRoutingExceptionsMetadataByNameResponse,
  terminationRoutingExceptionsMetadataByNameResponseSchema,
} from '../models/terminationRoutingExceptionsMetadataByNameResponse';
import {
  TerminationRoutingExceptionsMetadataResponse,
  terminationRoutingExceptionsMetadataResponseSchema,
} from '../models/terminationRoutingExceptionsMetadataResponse';
import {
  TerminationRoutingExceptionsResponse,
  terminationRoutingExceptionsResponseSchema,
} from '../models/terminationRoutingExceptionsResponse';
import {
  TnHistoryCleanup,
  tnHistoryCleanupSchema,
} from '../models/tnHistoryCleanup';
import {
  TnHistoryRecast,
  tnHistoryRecastSchema,
} from '../models/tnHistoryRecast';
import {
  TnsReprovisioningResponse,
  tnsReprovisioningResponseSchema,
} from '../models/tnsReprovisioningResponse';
import { TnTypePayload, tnTypePayloadSchema } from '../models/tnTypePayload';
import {
  TollFreeSettings,
  tollFreeSettingsSchema,
} from '../models/tollFreeSettings';
import {
  TollFreeSettingsResponse,
  tollFreeSettingsResponseSchema,
} from '../models/tollFreeSettingsResponse';
import {
  TrunkGroupsResponse,
  trunkGroupsResponseSchema,
} from '../models/trunkGroupsResponse';
import {
  UcTrunkingConfigurationPayload,
  ucTrunkingConfigurationPayloadSchema,
} from '../models/ucTrunkingConfigurationPayload';
import {
  UcTrunkingConfigurationResponse,
  ucTrunkingConfigurationResponseSchema,
} from '../models/ucTrunkingConfigurationResponse';
import { Vendor, vendorSchema } from '../models/vendor';
import { array, boolean, number, optional, string, unknown } from '../schema';
import { BaseController } from './baseController';

export class InternalController extends BaseController {
  /**
   * This API call retrieves information about the account indicated by the Account ID.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getPomAccount(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PomAccountResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}`;
    return req.callAsXml(
      'PomAccountResponse',
      pomAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates Account. <br>Note that the body is similar in structure to POST for /accounts. <br>Accounts
   * with Customer Segment set to Enterprise Telephony are not allowed to have SPID or Alternative SPID
   * configured. <br>There are some specific values for &lt;AssociatedCatapultAccount&gt; covered in
   * folow table:    <table style="text-align: left; width: 80%;" border="1" cellpadding="2"
   * cellspacing="2">       <tbody>          <tr>             <th>Existing value</th>             <th>New
   * value</th>             <th>Action description</th>          </tr>          <tr>
   * <td>empty</td>             <td>empty</td>             <td>Association for Account is not
   * provided</td>          </tr>          <tr>             <td>empty</td>             <td>string 'NEW'
   * (case sensitive)</td>             <td>Update Iris Account and set Associated Identifier equal to
   * Iris Account ID. New Assiciated Account with this ID is created on the external service</td>
   * </tr>          <tr>             <td>u-id(anyone)</td>             <td>string 'NEW' (case
   * sensitive)</td>             <td>Association and Account update can't be performed. There is no way
   * to change Association Identifier directly without removing a previous association</td>
   * </tr>          <tr>             <td>empty</td>             <td>Nonexistent u-id</td>
   * <td>Association and Account update can't be performed. There is no way to use Association Identifier
   * that doesn't exist</td>          </tr>          <tr>             <td>empty</td>             <td>u-id
   * value that is already associated with other Iris Account</td>             <td>Association and
   * Account update can't be performed. There is no way to use Associated Identifier that is associated
   * with other Iris Account</td>          </tr>          <tr>             <td>empty</td>
   * <td>Existing u-id value</td>             <td>Update Iris Account with association to new u-id</td>
   * </tr>          <tr>             <td>existing u-id</td>             <td>Nonexistent u-id
   * value</td>             <td>Association and Account update can't be performed. There is no way to use
   * Association Identifier that doesn't exist</td>          </tr>          <tr>             <td>existing
   * u-id</td>             <td>u-id value that is already associated with other Iris Account</td>
   * <td>Association and Account update can't be performed. There is no way to use Associated
   * Identifier that is associated with other Iris Account</td>          </tr>          <tr>
   * <td>existing u-id with assigned Applications on Account</td>             <td>new existing u-id</td>
   * <td>Association and Account update can't be performed. There is no way to reassign u-id
   * with already assigned Applications on Iris Account</td>          </tr>          <tr>
   * <td>existing u-id with assigned Applications on Account's Locations</td>             <td>new
   * existing u-id</td>             <td>Association and Account update can't be performed. There is no
   * way to reassign u-id with already assigned Applications on Iris Account's Locations</td>
   * </tr>          <tr>             <td>existing u-id</td>             <td>new existing u-id</td>
   * <td>Update Iris Account with association to new u-id</td>          </tr>          <tr>
   * <td>existing u-id</td>             <td>same existing u-id</td>             <td>Update Iris
   * Account without following association. Association already exists</td>          </tr>          <tr>
   * <td>value in Iris Account ID format</td>             <td>same value in format of Iris
   * Account ID</td>             <td>Update Iris Account without following association. Association
   * already exists</td>          </tr>          <tr>             <td>existing u-id</td>
   * <td>value in Iris Account ID format</td>             <td>Association and Account update can't be
   * performed. There is no way to change Association Identifier directly without removing a previous
   * association</td>          </tr>          <tr>             <td>empty</td>             <td>value in
   * Iris Account ID format</td>             <td>Association and Account update can't be performed. There
   * is no way explicitly to set Association Identifier in Iris Account ID format</td>          </tr>
   * <tr>             <td>value in Iris Account ID format</td>             <td>other value in Iris
   * Account ID format</td>             <td>Association and Account update can't be performed. There is
   * no way to set differ Association Identifier in Iris Account ID format</td>          </tr>
   * <tr>             <td>value in Iris Account ID format or u-id with assigned Applications on Account
   * or Locations</td>             <td>empty</td>             <td>Association and Account update can't be
   * performed. There is no way to remove association with existing Applications on Account or
   * Locations</td>          </tr>          <tr>             <td>value in Iris Account ID format or u-
   * id</td>             <td>empty</td>             <td>Update Iris Account. Association is removed</td>
   * </tr>       </tbody>    </table>    <br>  Field &lt;CustomerSegment&gt; is optional and can
   * have following values:  <table style="text-align: left; width: 80%;" border="1" cellpadding="2"
   * cellspacing="2">     <tbody>        <tr>           <th>Value</th>           <th>Description</th>
   * </tr>        <tr>           <td>EnterpriseTelephony</td>           <td>Allows Origination and
   * Termination products to be assigned to account, not allows UC trunking</td>        </tr>        <tr>
   * <td>UC</td>           <td>Allows UC trunking product and blocks Origination and
   * Termination products</td>        </tr>        <tr>           <td>Wholesale</td>           <td>Allows
   * Origination and Termination products to be assigned to account, not allows UC trunking</td>
   * </tr>        <tr>           <td>Trial</td>           <td>Does not limit products assignement. Allows
   * to switch to EnterpriseTelephony, UC or Wholesale customer segment, but reverse transition to Trial
   * from any other explicit segment is forbidden.</td>        </tr>        <tr>           <td>Wholesale-
   * implied</td>           <td>Is returned if account has Origination or Termination product and no
   * explicit customer segment set. On update this option is ignored</td>        </tr>        <tr>
   * <td>UC-implied</td>           <td>Is returned if account has UC product and no explicit customer
   * segment set. On update this option is ignored</td>        </tr>     </tbody>  </table>  <br>  <ul>
   * <li>If the Customer Segment has never been explicitly set, or has been explicitly set to Trial,
   * then you may set the Customer Segment to Wholesale, UC, or Enterprise Telephony, depending on the
   * products assigned to the account.</li>      <li>If the Customer Segment shows up as Wholesale-
   * implied, or UC-implied (in the GET response), it means the Customer Segment has never been
   * explicitly set for the account.</li>      <li>If an account has the UcTrunking product, the Customer
   * Segment can only be set to UC or Trial.</li>      <li>If an account has the Origination and/or
   * Termination products, the Customer Segment cannot be set to UC.</li>      <li>If the account has
   * never had a TN assigned, the Customer Segment may be changed according to the rules above. Otherwise
   * (if the account has had a TN assigned), if the Customer Segment has been explicitly set to Wholesale,
   * Enterprise Telephony, or UC, it cannot be changed.</li>  </ul>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updatePomAccount(
    accountId: number,
    body?: PomAccount,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PomAccountResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'PomAccount', optional(pomAccountSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}`;
    req.throwOn(409, ApiError, 'Conflict');
    return req.callAsXml(
      'PomAccountResponse',
      pomAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createSavePomAccount(
    accountId: number,
    body?: PomAccount,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PomAccountResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'PomAccount', optional(pomAccountSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}`;
    return req.callAsXml(
      'PomAccountResponse',
      pomAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async deletePomAccount(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<PomAccountResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}`;
    return req.callAsXml(
      'PomAccountResponse',
      pomAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @return Response from the API call
   */
  async getAllRegions(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<RegionsResponse>> {
    const req = this.createRequest('GET', '/');
    return req.callAsXml(
      'RegionsResponse',
      regionsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param body
   * @return Response from the API call
   */
  async createReprovisionTns(
    body?: TelephoneNumbers,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TnsReprovisioningResponse>> {
    const req = this.createRequest('POST', '/');
    req.xml('body', body, 'ReprovisionTns', optional(telephoneNumbersSchema));
    return req.callAsXml(
      'ReprovisionTnsResponse',
      tnsReprovisioningResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param tN
   * @param host
   * @return Response from the API call
   */
  async getAccountsSeacrch(
    tN?: string,
    host?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountSearchResponse>> {
    const req = this.createRequest('GET', '/search');
    const mapped = req.prepareArgs({
      tN: [tN, optional(string())],
      host: [host, optional(string())],
    });
    req.query('TN', mapped.tN);
    req.query('host', mapped.host);
    return req.callAsXml(
      'AccountSearchResponse',
      accountSearchResponseSchema,
      requestOptions
    );
  }

  /**
   * Add a new product to the account, features can be added together with product
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createAccountProduct(
    accountId: number,
    body?: AccountProduct,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountProductResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'Product', optional(accountProductSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/products`;
    return req.callAsXml(
      'AccountProductResponse',
      accountProductResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param productName
   * @param body
   * @return Response from the API call
   */
  async updateAccountProduct(
    accountId: number,
    productName: string,
    body?: AccountProduct,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountProductResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      productName: [productName, string()],
    });
    req.xml('body', body, 'Product', optional(accountProductSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/${mapped.productName}`;
    return req.callAsXml(
      'AccountProductResponse',
      accountProductResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve messaging analytics, where the Message Detail Record (MDRs) are chosen based on the search
   * parameters provided in the API Call.
   *
   * @param accountId
   * @param messageId
   * @param sourceTn
   * @param destinationTn
   * @param fromDateTime
   * @param toDateTime
   * @param messageStatus
   * @param errorCode
   * @param pageToken
   * @return Response from the API call
   */
  async getAccountAnalyticsMessagingMdrs(
    accountId: number,
    messageId?: string,
    sourceTn?: string,
    destinationTn?: string,
    fromDateTime?: string,
    toDateTime?: string,
    messageStatus?: string,
    errorCode?: number,
    pageToken?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      messageId: [messageId, optional(string())],
      sourceTn: [sourceTn, optional(string())],
      destinationTn: [destinationTn, optional(string())],
      fromDateTime: [fromDateTime, optional(string())],
      toDateTime: [toDateTime, optional(string())],
      messageStatus: [messageStatus, optional(string())],
      errorCode: [errorCode, optional(number())],
      pageToken: [pageToken, optional(string())],
    });
    req.query('messageId', mapped.messageId);
    req.query('sourceTn', mapped.sourceTn);
    req.query('destinationTn', mapped.destinationTn);
    req.query('fromDateTime', mapped.fromDateTime);
    req.query('toDateTime', mapped.toDateTime);
    req.query('messageStatus', mapped.messageStatus);
    req.query('errorCode', mapped.errorCode);
    req.query('pageToken', mapped.pageToken);
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/analytics/messaging/mdrs`;
    req.throwOn(400, ApiError, 'Bad Request - Account has no messaging analytics feature assigned');
    req.throwOn(403, ApiError, 'Forbidden - Loged in user has no requested account assigned');
    req.throwOn(503, ApiError, 'Service Temporarily Unavailable - Message search api temporary unavailable');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Create a Campaign ID or update its description. Campaign ID and Description are required. Account ID
   * must be empty or an existing Account ID. <br>The Campaign ID should be:<ul>    <li>equal to an {id}
   * parameter in URL</li>    <li>globally unique</li>    <li>a non-empty string no longer than 64
   * characters long</li>    <li>only alphanumeric values, dashes, underscores, singular whitespaces and
   * dots are allowed</li>    <li>whitespaces are only allowed inside the string, and they should not be
   * consecutive</li></ul>
   *
   * @param id
   * @param body
   * @return Response from the API call
   */
  async updateAdminData(
    id: string,
    body?: A2pCampaignId,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      body: [body, optional(a2pCampaignIdSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/a2pcampaignids/${mapped.id}`;
    req.throwOn(400, ApiError, 'Validation error. Possible reasons:<ul>    <li>Code 12820: Campaign ID in the link and in the body is not the same.</li>    <li>Code 12822: A2P Campaign ID \'Campaign/1\' is not valid. Needs to be between 1 and 64 characters.    Only alphanumeric values, dashes, underscores, singular whitespaces and dots are allowed.    Whitespaces at the beginning or at the end of string are not allowed.</li>    <li>Code 12836:The provided Account Id \'**\' is not a valid Account Id.</ul>');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Delete Campaign ID.
   *
   * @param id
   * @return Response from the API call
   */
  async deleteAdminData(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/a2pcampaignids/${mapped.id}`;
    req.throwOn(404, ApiError, 'Campaign ID not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Create or update A2P Class.
   *
   * @param id
   * @param body
   * @return Response from the API call
   */
  async updateAdminData1(
    id: string,
    body?: A2pClass,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      body: [body, optional(a2pClassSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/a2pclasses/${mapped.id}`;
    req.throwOn(400, ApiError, 'Validation error');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Delete A2P Class.
   *
   * @param id
   * @return Response from the API call
   */
  async deleteAdminData1(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/a2pclasses/${mapped.id}`;
    req.throwOn(404, ApiError, 'A2P Class not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get Break Out Country.
   *
   * @param breakOutCountry
   * @return Response from the API call
   */
  async getAdminData2(
    breakOutCountry: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AdminDataResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      breakOutCountry: [breakOutCountry, string()],
    });
    req.appendTemplatePath`/admin/data/breakoutcountries/${mapped.breakOutCountry}`;
    req.throwOn(404, ApiError, 'Break Out Country does not exist');
    return req.callAsXml(
      'AdminDataResponse',
      adminDataResponseSchema,
      requestOptions
    );
  }

  /**
   * Create or update Break Out Country settings. The "Name" field is optional and will not be retained.
   * Validations:<br> - The 3 letter country code should belong to an existing country - The Break Out
   * Country in the URL should match the 3 letter country code in the payload - "CountryCode" field
   * should consist of 1-3 digits - Each "Digits" field should consist of 1-4 digits
   *
   * @param breakOutCountry
   * @param body
   * @return Response from the API call
   */
  async updateAdminData2(
    breakOutCountry: string,
    body?: BreakOutCountry,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      breakOutCountry: [breakOutCountry, string()],
      body: [body, optional(breakOutCountrySchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/breakoutcountries/${mapped.breakOutCountry}`;
    req.throwOn(400, ApiError, 'Validation error');
    req.throwOn(404, ApiError, 'Break Out Country does not exist');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Delete Break Out Country.
   *
   * @param breakOutCountry
   * @return Response from the API call
   */
  async deleteAdminData2(
    breakOutCountry: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      breakOutCountry: [breakOutCountry, string()],
    });
    req.appendTemplatePath`/admin/data/breakoutcountries/${mapped.breakOutCountry}`;
    req.throwOn(404, ApiError, 'Break Out Country does not exist');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get all existing Break Out Countries.
   *
   * @return Response from the API call
   */
  async getAllAdminData2(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/breakoutcountries');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param id
   * @param body
   * @return Response from the API call
   */
  async updateAdminData10(
    id: string,
    body?: SbcNodeGroup,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      body: [body, optional(sbcNodeGroupSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/${mapped.id}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param id
   * @return Response from the API call
   */
  async deleteAdminData9(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/${mapped.id}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Update settings for a country.&lt;Country&gt; can have the following values:    <table style="text-
   * align: left; width: 80%;" border="1" cellpadding="2" cellspacing="2">    <tbody>        <tr>
   * <th>Value></th>            <th>Description</th>        </tr>        <tr>
   * <td>CountryName</td>            <td>Name of the country. This field is required and is not updatable
   * via this API.</td>        </tr>        <tr>            <td>ThreeLetterCode</td>            <td>Three
   * letter code of the country. This field is required and is not updatable via this API.</td>
   * </tr>        <tr>            <td>TwoLetterCode</td>            <td>Two letter code of the country.
   * This field is required and is not updatable via this API.</td>        </tr>        <tr>
   * <td>Supported</td>            <td>Determines whether or not Bandwidth supports numbers from this
   * country. This field is required.</td>        </tr>    </tbody>    </table>
   *
   * @param countryId
   * @param body
   * @return Response from the API call
   */
  async updateAdminData4(
    countryId: string,
    body?: Country,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      countryId: [countryId, string()],
      body: [body, optional(countrySchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/countries/${mapped.countryId}`;
    req.throwOn(400, ApiError, 'Validation error');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get details on all countries in the system
   *
   * @return Response from the API call
   */
  async getAllAdminData4(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/countries');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get current settings for an international vendor.
   *
   * @param vendorId
   * @return Response from the API call
   */
  async getAdminData4(
    vendorId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ vendorId: [vendorId, string()] });
    req.appendTemplatePath`/admin/data/internationalvendorsettings/${mapped.vendorId}`;
    req.throwOn(404, ApiError, 'International settings not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Update settings for an international vendor.&lt;InternationalVendor&gt; can have the following
   * values:    <table style="text-align: left; width: 80%;" border="1" cellpadding="2" cellspacing="2">
   * <tbody>        <tr>            <th>Value</th>            <th>Description</th>        </tr>
   * <tr>            <td>VendorId</td>            <td>Id of the vendor that these international settings
   * apply to. This field is required.</td>        </tr>        <tr>            <td>Supported</td>
   * <td>Specifies whether the vendor is currently a supported international vendor.</td>
   * </tr>    </tbody>    </table>
   *
   * @param vendorId
   * @param body
   * @return Response from the API call
   */
  async updateAdminData5(
    vendorId: string,
    body?: InternationalVendor,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      vendorId: [vendorId, string()],
      body: [body, optional(internationalVendorSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/internationalvendorsettings/${mapped.vendorId}`;
    req.throwOn(400, ApiError, 'Validation error');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Delete international vendor settings.
   *
   * @param vendorId
   * @return Response from the API call
   */
  async deleteAdminData4(
    vendorId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ vendorId: [vendorId, string()] });
    req.appendTemplatePath`/admin/data/internationalvendorsettings/${mapped.vendorId}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get international-specific settings for international vendors
   *
   * @return Response from the API call
   */
  async getAllAdminData5(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest(
      'GET',
      '/admin/data/internationalvendorsettings'
    );
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Create settings for an international vendor.<br/>&lt;InternationalVendor&gt; can have the following
   * values:    <table style="text-align: left; width: 80%;" border="1" cellpadding="2" cellspacing="2">
   * <tbody>        <tr>            <th>Value</th>            <th>Desription</th>        </tr>
   * <tr>            <td>VendorId</td>            <td>Id of the vendor that these international settings
   * apply to. This field is required.</td>        </tr>        <tr>            <td>Supported</td>
   * <td>Specifies whether the vendor is currently a supported international vendor.</td>
   * </tr>    </tbody>    </table>
   *
   * @param body
   * @return Response from the API call
   */
  async createAdminData(
    body?: InternationalVendor,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest(
      'POST',
      '/admin/data/internationalvendorsettings'
    );
    const mapped = req.prepareArgs({
      body: [body, optional(internationalVendorSchema)],
    });
    req.json(mapped.body);
    req.throwOn(400, ApiError, 'Validation error');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param l3ErrorCode
   * @return Response from the API call
   */
  async getAdminData5(
    l3ErrorCode: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ l3ErrorCode: [l3ErrorCode, string()] });
    req.appendTemplatePath`/${mapped.l3ErrorCode}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param l3ErrorCode
   * @param body
   * @return Response from the API call
   */
  async updateAdminData6(
    l3ErrorCode: string,
    body?: Level3PortingErrorSettingPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      l3ErrorCode: [l3ErrorCode, string()],
      body: [body, optional(level3PortingErrorSettingPayloadSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/${mapped.l3ErrorCode}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param l3ErrorCode
   * @return Response from the API call
   */
  async deleteAdminData5(
    l3ErrorCode: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ l3ErrorCode: [l3ErrorCode, string()] });
    req.appendTemplatePath`/${mapped.l3ErrorCode}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Allows the user update the account pom configuration.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateAdminData3(
    accountId: number,
    body?: MessagingBlockedAccountId,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      body: [body, optional(messagingBlockedAccountIdSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/blockedaccount/${mapped.accountId}`;
    req.throwOn(400, ApiError, 'Some information is not correct.');
    req.throwOn(404, ApiError, 'Pom account configuration not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Removing pom account configuration.
   *
   * @param accountId
   * @return Response from the API call
   */
  async deleteAdminData3(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/admin/data/blockedaccount/${mapped.accountId}`;
    req.throwOn(404, ApiError, 'User was not found.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get NNRoute.
   *
   * @param id
   * @return Response from the API call
   */
  async getAdminData8(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/nnroutes/${mapped.id}`;
    req.throwOn(404, ApiError, 'NNRoute not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Allows to create or update NNRoute.
   *
   * @param id
   * @param body
   * @return Response from the API call
   */
  async updateAdminData8(
    id: string,
    body?: NnRoute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      body: [body, optional(nnRouteSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/nnroutes/${mapped.id}`;
    req.throwOn(400, ApiError, 'Validation error');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Delete NNRoute.
   *
   * @param id
   * @return Response from the API call
   */
  async deleteAdminData7(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/nnroutes/${mapped.id}`;
    req.throwOn(404, ApiError, 'NNRoute not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get all NNRoutes
   *
   * @param nameFragment
   * @return Response from the API call
   */
  async getAllAdminData7(
    nameFragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/nnroutes');
    const mapped = req.prepareArgs({
      nameFragment: [nameFragment, optional(string())],
    });
    req.query('nameFragment', mapped.nameFragment);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Create a proxy sippeer or update its service type. All fields in the payload are required <br>The
   * proxy peer name should be:<ul>    <li>equal to an {name} parameter in URL</li>    <li>globally
   * unique</li>    <li>a non-empty string no longer than 64 characters long</li></ul>
   *
   * @param id
   * @param body
   * @return Response from the API call
   */
  async updateAdminData9(
    id: string,
    body?: ProxyPeerValue,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      body: [body, optional(proxyPeerValueSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/proxypeers/${mapped.id}`;
    req.throwOn(400, ApiError, 'Validation error.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Delete proxy sipppeer
   *
   * @param id
   * @return Response from the API call
   */
  async deleteAdminData8(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/proxypeers/${mapped.id}`;
    req.throwOn(404, ApiError, 'Proxy sipppeer not found');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param body
   * @return Response from the API call
   */
  async createAdminData2(
    body?: SbcNodeGroup,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST', '/admin/data/sbcnodegroups');
    const mapped = req.prepareArgs({
      body: [body, optional(sbcNodeGroupSchema)],
    });
    req.json(mapped.body);
    req.throwOn(400, ApiError, 'invalid sbc node parameters, duplicate node names or empty node names aren\'t accepted');
    req.throwOn(409, ApiError, 'this sbc group name already exists in IRIS');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Allows replacement of a specified System Event Subscription. See endpoint
   * /admin/data/systemEventSubscriptions for details about the elements.
   *
   * @param id
   * @param body
   * @return Response from the API call
   */
  async updateAdminData7(
    id: string,
    body?: SystemEventSubscription,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      body: [body, optional(systemEventSubscriptionSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/systemeventsubscriptions/${mapped.id}`;
    req.throwOn(400, ApiError, 'Validation error');
    req.throwOn(404, ApiError, 'SystemEventSubscription not found');
    req.throwOn(409, ApiError, 'Update to current SystemEventSubscription violates uniqueness constraint');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Allows removal of a specified System Event Subscription. Once the subscription is removed, the
   * notifications will no longer be sent.
   *
   * @param id
   * @return Response from the API call
   */
  async deleteAdminData6(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/systemeventsubscriptions/${mapped.id}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Allows creation of a single System Event Subscription. The payload elements are as follows:
   * <br/><table>       <tr><th> Element </th><th> Required </th><th> Usage </th></tr>       <tr><td>
   * SubscriptionId </td><td> No </td><td> This element should generally be omitted for new entries. It
   * simply provides a unique identifier for the subscription. </td></tr>       <tr><td>    SystemEvent
   * </td><td> Yes </td><td> Specifies the event to which you are subscribing. Must be one of the values
   * listed above. </td></tr>       <tr><td>    Email </td><td> No* </td><td> For notification via email,
   * specifies the email address to which the notification information is sent. </td></tr>       <tr><td>
   * ZendeskGroupId </td><td> No* </td><td> For notification via Zendesk ticket, specifies the Zendesk
   * queue number to which the notification information is sent. </td></tr>       <tr><td>
   * CallbackOrderType </td><td> No* </td><td> For notification via API callback, specifies the
   * predefined order type for which notification information will be sent via the predefined callback
   * URL. </td></tr>       <tr><td>    DigestType </td><td> No </td><td> Values: daily, none. Specifies
   * whether you wish to receive a daily digest of event instances instead of a notification for each
   * event instance. Value daily is not supported for all events. </td></tr></table>* Exactly one of
   * Email, ZendeskGroupId, or CallbackOrderType must be specified. Most events support only one type of
   * notification.
   *
   * @param body
   * @return Response from the API call
   */
  async createAdminData3(
    body?: SystemEventSubscription,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest(
      'POST',
      '/admin/data/systemeventsubscriptions'
    );
    const mapped = req.prepareArgs({
      body: [body, optional(systemEventSubscriptionSchema)],
    });
    req.json(mapped.body);
    req.throwOn(400, ApiError, 'Validation error');
    req.throwOn(409, ApiError, 'Such SystemEventSubscription already exists');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get TnType
   *
   * @param tnTypeId
   * @return Response from the API call
   */
  async getAdminData13(
    tnTypeId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ tnTypeId: [tnTypeId, string()] });
    req.appendTemplatePath`/admin/data/tntypes/${mapped.tnTypeId}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Update TnType
   *
   * @param tnTypeId
   * @param body
   * @return Response from the API call
   */
  async updateAdminData11(
    tnTypeId: string,
    body?: TnTypePayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      tnTypeId: [tnTypeId, string()],
      body: [body, optional(tnTypePayloadSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/tntypes/${mapped.tnTypeId}`;
    req.throwOn(400, ApiError, 'Validation failed');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get TnType
   *
   * @return Response from the API call
   */
  async getAllAdminData11(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/admin/data/tntypes');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Create a new TnType
   *
   * @param body
   * @return Response from the API call
   */
  async createGetAdminData12(
    body?: TnTypePayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST', '/admin/data/tntypes');
    const mapped = req.prepareArgs({
      body: [body, optional(tnTypePayloadSchema)],
    });
    req.json(mapped.body);
    req.throwOn(400, ApiError, 'Validation error');
    req.throwOn(409, ApiError, 'Source/Type combination is already present. Use PUT under /{id} to enable/disable the TnType');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Allows to create or update Vendor.
   *
   * @param id
   * @param body
   * @return Response from the API call
   */
  async updateAdminData12(
    id: string,
    body?: Vendor,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      body: [body, optional(vendorSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/admin/data/vendors/${mapped.id}`;
    req.throwOn(400, ApiError, 'Validation error');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Delete Vendor.
   *
   * @param id
   * @return Response from the API call
   */
  async deleteAdminData10(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/admin/data/vendors/${mapped.id}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async deleteAdminData11(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/${mapped.accountId}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param sippeerId
   * @param body
   * @return Response from the API call
   */
  async updateAdminData13(
    sippeerId: string,
    body?: SlingshotEnv,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      sippeerId: [sippeerId, string()],
      body: [body, optional(slingshotEnvSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/${mapped.sippeerId}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param sippeerId
   * @return Response from the API call
   */
  async deleteAdminData12(
    sippeerId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ sippeerId: [sippeerId, string()] });
    req.appendTemplatePath`/${mapped.sippeerId}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.Some of the
   * important values that are established as part of this termination are...
   * <table><tr><th>parameter</th><th>description</th></tr><tr><td>DashUserId</td><td>[Alphanumeric with
   * symbols] the User ID to be used to access Dash for this Bandwidth Dashboard API
   * account</td></tr><tr><td>DashPassword</td><td>[Alphanumeric with symbols] the Password to be used to
   * access Dash for this Bandwidth Dashboard API account</td></tr><tr><td>Hosts</td><td>List of IP
   * ranges to be used only for e911 traffic</td></tr></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateE911Configuration(
    accountId: number,
    body?: E911Settings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<E911SettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'E911Settings', optional(e911SettingsSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/e911/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the E911 settings resource is incorrect or other factors prevent execution of the POST  The error contains an error code and description.');
    return req.callAsXml(
      'E911SettingsResponse',
      e911SettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.Some of the
   * important values that are established as part of this termination are...
   * <table><tr><th>parameter</th><th>description</th></tr><tr><td>DashUserId</td><td>[Alphanumeric with
   * symbols] the User ID to be used to access Dash for this Bandwidth Dashboard API account. 50
   * characters, ascii, without % symbol or whitespace.
   * </td></tr><tr><td>DashPassword</td><td>[Alphanumeric] the Password to be used to access Dash for
   * this Bandwidth Dashboard API account - 50 characters</td></tr><tr><td>Hosts</td><td>List of IP
   * ranges to be used only for e911 traffic</td></tr></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createE911Configuration(
    accountId: number,
    body?: E911Settings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<E911SettingsResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'E911Settings', optional(e911SettingsSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/e911/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the E911 settings resource is incorrect or other factors prevent execution of the POST  The error contains an error code and description.');
    return req.callAsXml(
      'E911SettingsResponse',
      e911SettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * This Edge Management settings resource can be PUT or POSTed to in order to establish the appropriate
   * settings.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateEdgeManagementConfiguration(
    accountId: number,
    body?: EdgeManagementConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EdgeManagementConfigurationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'EdgeManagementSettings',
      optional(edgeManagementConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/edgemanagement/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the edge Management settings resource is incorrect or the account is not configured for Edge Management.  The error contains an error code and description.');
    return req.callAsXml(
      'EdgeManagementSettingsResponse',
      edgeManagementConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * This Edge Management settings resource can be PUT or POSTed to in order to establish the appropriate
   * settings.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createEdgeManagementConfiguration(
    accountId: number,
    body?: EdgeManagementConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EdgeManagementConfigurationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'EdgeManagementSettings',
      optional(edgeManagementConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/edgemanagement/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the edge Management settings resource is incorrect or the account is not configured for Edge Management.  The error contains an error code and description.');
    return req.callAsXml(
      'EdgeManagementSettingsResponse',
      edgeManagementConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param holidayDate
   * @param body
   * @return Response from the API call
   */
  async updateHoliday(
    holidayDate: string,
    body?: HolidayPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<HolidayResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ holidayDate: [holidayDate, string()] });
    req.xml('body', body, 'Holiday', optional(holidayPayloadSchema));
    req.appendTemplatePath`/${mapped.holidayDate}`;
    return req.callAsXml(
      'HolidayResponse',
      holidayResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param holidayDate
   * @return Response from the API call
   */
  async deleteHoliday(
    holidayDate: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<HolidayResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ holidayDate: [holidayDate, string()] });
    req.appendTemplatePath`/${mapped.holidayDate}`;
    return req.callAsXml(
      'HolidayResponse',
      holidayResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be used for PUT to establish the appropriate settings. Messaging settings cannot
   * be changed if previous settings are not applied yet.Some of the important values that are
   * established as part of this termination are...<table>
   * <tr><th>parameter</th><th>description</th></tr>    <tr><td>Enabled</td><td>[Boolean] flag to
   * enable/disable Messaging product on the account. Value is required.</td></tr>
   * <tr><td>EnabledOnNewTN</td><td>[Boolean] flag to enable/disable Messaging feature on each new
   * telephone number. Value is required if Enabled = true </td></tr>
   * <tr><td>ExistingTNAction</td><td>[Enum] action will be performed to all existing telephone numbers
   * on the account. Valid values: enable, disable, nochange.</td></tr>
   * <tr><td>SupportedOnImportedTns</td><td>[Boolean] Whether the account can assign non-Bandwidth TNs
   * for Messaging. The default is false.</td><tr>    <tr><td>PreventUpdatingNetNumber</td><td>[Boolean]
   * flag to block NetNumber updates on all of the TNs on the account. The default is false.</td></tr>
   * <tr><td>EnableOnNetMessageRoutes</td><td>[Boolean] flag to enable/disable message routing on the
   * Bandwidth messaging network. The default is true.</td></tr>
   * <tr><td>EnableOffNetMessageRoutes</td><td>[Boolean] flag to enable/disable message routing around
   * the Bandwidth messaging network. The default is false.</td></tr>
   * <tr><td>ProxyPeersOwner</td><td>[Boolean] flag to enable/disable the ability of having sipPeers that
   * could be used as proxy peers for http messaging. </td><tr>
   * <tr><td>BreakOutCountries</td><td>[List] Holds list of breakout countries. </td><tr></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateMessagingSettings(
    accountId: number,
    body?: MessagingSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MessagingSettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'MessagingSettings',
      optional(messagingSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the SMS settings resource is incorrect or other factors prevent execution of the POST. The error contains an error code and description.');
    return req.callAsXml(
      'MessagingSettingsResponse',
      messagingSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be used for POST to establish the appropriate settings.Some of the important
   * values that are established as part of this termination are...<table>
   * <tr><th>parameter</th><th>description</th></tr>    <tr><td>Enabled</td><td>[Boolean] flag to
   * enable/disable Messaging product on the account. Value is required.</td></tr>
   * <tr><td>EnabledOnNewTN</td><td>[Boolean] flag to enable/disable Messaging feature on each new
   * telephone number. Value is required if Enabled = true </td></tr>
   * <tr><td>ExistingTNAction</td><td>[Enum] action will be performed to all existing telephone numbers
   * on the account. Valid values: enable, disable, nochange.</td></tr>
   * <tr><td>SupportedOnImportedTns</td><td>[Boolean] Whether the account can assign non-Bandwidth TNs
   * for Messaging. The default is false.</td><tr>    <tr><td>PreventUpdatingNetNumber</td><td>[Boolean]
   * flag to block NetNumber updates on all of the TNs on the account. The default is false.</td></tr>
   * <tr><td>EnableOnNetMessageRoutes</td><td>[Boolean] flag to enable/disable message routing on the
   * Bandwidth messaging network. The default is true.</td></tr>
   * <tr><td>EnableOffNetMessageRoutes</td><td>[Boolean] flag to enable/disable message routing around
   * the Bandwidth messaging network. The default is false.</td></tr>
   * <tr><td>ProxyPeersOwner</td><td>[Boolean] flag to enable/disable the ability of having sipPeers that
   * could be used as proxy peers for http messaging. </td><tr>
   * <tr><td>BreakOutCountries</td><td>[List] Holds list of breakout countries, if empty, current
   * countries will be removed. </td><tr></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createMessagingSettings(
    accountId: number,
    body?: MessagingSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MessagingSettingsResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'MessagingSettings',
      optional(messagingSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the Messaging settings resource is incorrect or other factors prevent execution of the POST. The error contains an error code and description.');
    return req.callAsXml(
      'MessagingSettingsResponse',
      messagingSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be used to establish the appropriate messaging routes for various types of TNs
   * described in the GET above.It is assumed that the MessagingRoutes resource exists if the messaging
   * product has been configured.<br>The description of the payload values is provided in the description
   * of the GET above, as has the implications of 0,1 or many routes associated withany specific type of
   * TN.<br>PUT of an empty list will remove all of the routes associated with the account.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateSetAccountRoutes(
    accountId: number,
    body?: MessagingRoutes,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountMessagingRoutesResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'MessagingRoutes', optional(messagingRoutesSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/routes`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned if user tries to create/update routs with incorrrect TnType, sets the indentical routes or provide not only one default route per TnType. E.g. in case with more then one defaul NNID per Tn Type');
    req.throwOn(409, ApiError, 'a 409 CONFLICT will be returned if user tries to create/update routs with NNID which doesn\'t present in the system.');
    return req.callAsXml(
      'AccountMessagingRoutesResponse',
      accountMessagingRoutesResponseSchema,
      requestOptions
    );
  }

  /**
   * update sms feature settings
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateSmsFeature(
    accountId: number,
    body?: AccountSmsFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountSmsFeatureResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'AccountSmsFeature',
      optional(accountSmsFeatureSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/sms`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Trying to change \'%s\' feature settings but that feature is not enabled for account %d.</li></ul>');
    return req.callAsXml(
      'AccountSmsFeatureResponse',
      accountSmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * add sms feature settings
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createSmsFeature(
    accountId: number,
    body?: AccountSmsFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountSmsFeatureResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'AccountSmsFeature',
      optional(accountSmsFeatureSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/sms`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Trying to change \'%s\' feature settings but that feature is not enabled for account %d.</li>   <li>%s is required</li></ul>');
    return req.callAsXml(
      'AccountSmsFeatureResponse',
      accountSmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * update http feature settings
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateHttpFeature(
    accountId: number,
    body?: AccountHttpFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountHttpFeatureResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'AccountHttpFeature',
      optional(accountHttpFeatureSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/http`;
    req.throwOn(400, ApiError, 'Specified sippeer id does not exist <br>');
    return req.callAsXml(
      'AccountHttpFeatureResponse',
      accountHttpFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * add http feature settings
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createHttpFeature(
    accountId: number,
    body?: AccountHttpFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountHttpFeatureResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'AccountHttpFeature',
      optional(accountHttpFeatureSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/http`;
    req.throwOn(400, ApiError, 'Specified sippeer id does not exist <br>');
    return req.callAsXml(
      'AccountHttpFeatureResponse',
      accountHttpFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * delete http settings
   *
   * @param accountId
   * @return Response from the API call
   */
  async deleteHttpFeature(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountHttpFeatureResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/http`;
    req.throwOn(404, ApiError, 'http settings were not found');
    return req.callAsXml(
      'AccountHttpFeatureResponse',
      accountHttpFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * update mms feature settings
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateMmsFeatureMm4Settings(
    accountId: number,
    body?: Mm4Settings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MmsFeatureMm4SettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'MM4Settings', optional(mm4SettingsSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/mms/mm4settings`;
    req.throwOn(400, ApiError, 'mm4 settings are not allowed if mm4 is disabled <br>');
    return req.callAsXml(
      'MmsFeatureMm4AdminSettingsResponse',
      mmsFeatureMm4SettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * update mms feature settings
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateMmsFeature(
    accountId: number,
    body?: AccountMmsFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountMmsFeatureResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'AccountMmsFeature',
      optional(accountMmsFeatureSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/mms`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Trying to change \'%s\' feature settings but that feature is not enabled for account %d.</li>   <li>mm4Settings is not allowed/li></ul>');
    return req.callAsXml(
      'AccountMmsFeatureResponse',
      accountMmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * set mms feature settings
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createMmsFeature(
    accountId: number,
    body?: AccountMmsFeature,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountMmsFeatureResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'AccountMmsFeature',
      optional(accountMmsFeatureSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/mms`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>Trying to change \'%s\' feature settings but that feature is not enabled for account %d.</li>   <li>Specified sippeer id does not exist</li>   <li>mm4AdminSettings is required</li></ul>');
    return req.callAsXml(
      'AccountMmsFeatureResponse',
      accountMmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * delete mms settings
   *
   * @param accountId
   * @return Response from the API call
   */
  async deleteMmsFeature(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountMmsFeatureResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/messaging/features/mms`;
    req.throwOn(404, ApiError, 'mms settings were not found');
    return req.callAsXml(
      'AccountMmsFeatureResponse',
      accountMmsFeatureResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param body
   * @return Response from the API call
   */
  async updateMigration(
    body?: BocAccountList,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT', '/bocAcctList');
    req.xml('body', body, 'BocAcctList', optional(bocAccountListSchema));
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param body
   * @return Response from the API call
   */
  async createMigration(
    body?: BocAccountList,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST', '/bocAcctList');
    req.xml('body', body, 'BocAcctList', optional(bocAccountListSchema));
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param countryCode
   * @return Response from the API call
   */
  async getMigration(
    countryCode: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ countryCode: [countryCode, string()] });
    req.appendTemplatePath`/bocAcctList/${mapped.countryCode}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param rollbackAccountId
   * @return Response from the API call
   */
  async getMigrations(
    rollbackAccountId?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/ganProfileAttribute');
    const mapped = req.prepareArgs({
      rollbackAccountId: [rollbackAccountId, optional(number())],
    });
    req.query('rollbackAccountId', mapped.rollbackAccountId);
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateMigrateAccount(
    accountId: number,
    body: GanProfileAttributeMigration,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'GanProfileAttributeMigration',
      ganProfileAttributeMigrationSchema
    );
    req.appendTemplatePath`/ganProfileAttribute/${mapped.accountId}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param body
   * @return Response from the API call
   */
  async post(
    body?: NnidAccountSync,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST', '/nnidAccountSync');
    req.xml('body', body, 'NnidAccountSync', optional(nnidAccountSyncSchema));
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param tnHistory
   * @param tag
   * @param accountId
   * @return Response from the API call
   */
  async get(
    tnHistory: string,
    tag?: string,
    accountId?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      tnHistory: [tnHistory, string()],
      tag: [tag, optional(string())],
      accountId: [accountId, optional(number())],
    });
    req.query('tag', mapped.tag);
    req.query('accountId', mapped.accountId);
    req.appendTemplatePath`/${mapped.tnHistory}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param tnHistory
   * @param body
   * @return Response from the API call
   */
  async post1(
    tnHistory: string,
    body?: TnHistoryRecast,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ tnHistory: [tnHistory, string()] });
    req.xml('body', body, 'TnHistoryRecast', optional(tnHistoryRecastSchema));
    req.appendTemplatePath`/${mapped.tnHistory}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param tnHistory
   * @param body
   * @return Response from the API call
   */
  async deleteCleanupOldHistories(
    tnHistory: string,
    body?: TnHistoryCleanup,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ tnHistory: [tnHistory, string()] });
    req.xml('body', body, 'TnHistoryCleanup', optional(tnHistoryCleanupSchema));
    req.appendTemplatePath`/${mapped.tnHistory}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Examine the Numbermanagement settings of the account.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getNumberManagementSettings(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NumberManagementSettings>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/numbermanagement/settings`;
    req.throwOn(400, ApiError, 'Numbermanagement product is not enabled on account');
    req.throwOn(404, ApiError, 'There are no Numbermanagement settings for account');
    return req.callAsXml(
      'NumberManagementSettings',
      numberManagementSettingsSchema,
      requestOptions
    );
  }

  /**
   * Update Numbermanagement product settings on the account.Acceptable values for the
   * FalloutManagementGrade are 1, 2, and 3.To delete cnamdip settings no CnamDip element should be sent.
   * To set default value of FalloutManagementGrade no LNP element should be sent.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateNumberManagementSettings(
    accountId: number,
    body?: NumberManagementSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NumberManagementSettings>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'NumberManagementSettings',
      optional(numberManagementSettingsSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/numbermanagement/settings`;
    req.throwOn(400, ApiError, 'LnpFalloutManagement feature is not set on the account, or validation issue with given TnType/Vendor/Country');
    return req.callAsXml(
      'NumberManagementSettings',
      numberManagementSettingsSchema,
      requestOptions
    );
  }

  /**
   * The GET returns the current settings, describing the inbound and bidirectional traffic levels that
   * will be permitted.  See the
   *
   * @param accountId
   * @return Response from the API call
   */
  async getOriginationConfiguration(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<OriginationConfigurationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/origination/settings`;
    req.throwOn(400, ApiError, 'BAD REQUESTIf the settings are not present for the Origination product a 404 NOT FOUND is returned with an explanatory payload.');
    req.throwOn(404, ApiError, 'NOT FOUNDIf the product exists on the account, but settings are missing, then the not found response is used.');
    return req.callAsXml(
      'OriginationSettingResponse',
      originationConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.Some of the
   * important values that are established as part of this termination are...
   * <table><tr><th>parameter</th><th>description</th></tr><tr><td>ConcurrentInboundCalls</td><td>integer
   * </td></tr><tr><td>ConcurrentBidirectionalCalls</td><td>integer</td></tr><tr><td>RedirectEnabled</td>
   * <td>true | false - enables 3xx redirection routing for account</td></tr></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateOriginationConfiguration(
    accountId: number,
    body?: OriginationConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<OriginationConfigurationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'OriginationSettings',
      optional(originationConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/origination/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the termination settings resource is incorrect or other factors prevent execution of the POST  The error contains an error code and description.');
    return req.callAsXml(
      'OriginationSettingResponse',
      originationConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.Some of the
   * important values that are established as part of this termination are...
   * <table><tr><th>parameter</th><th>description</th></tr><tr><td>ConcurrentInboundCalls</td><td>integer
   * </td></tr><tr><td>ConcurrentBidirectionalCalls</td><td>integer</td></tr><tr><td>RedirectEnabled</td>
   * <td>true | false - enables 3xx redirection routing for account</td></tr></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createOriginationConfiguration(
    accountId: number,
    body?: OriginationConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<OriginationConfigurationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'OriginationSettings',
      optional(originationConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/origination/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the termination settings resource is incorrect or other factors prevent execution of the POST  The error contains an error code and description.');
    return req.callAsXml(
      'OriginationSettingResponse',
      originationConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param productname
   * @return Response from the API call
   */
  async getProduct(
    productname: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ productname: [productname, string()] });
    req.appendTemplatePath`/${mapped.productname}`;
    return req.callAsXml(
      'ProductResponse',
      productResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param propertyName
   * @param body
   * @return Response from the API call
   */
  async updateFlipProperty(
    propertyName: string,
    body?: SettingPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ProductsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ propertyName: [propertyName, string()] });
    req.xml('body', body, 'Setting', optional(settingPayloadSchema));
    req.appendTemplatePath`/${mapped.propertyName}`;
    return req.callAsXml(
      'ProductsResponse',
      productsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param page
   * @param size
   * @param accountId
   * @param usernamefragment
   * @param domainfragment
   * @return Response from the API call
   */
  async getSipCredentials1(
    page?: string,
    size?: number,
    accountId?: number,
    usernamefragment?: string,
    domainfragment?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipCredentials>> {
    const req = this.createRequest('GET', '/sipCredentials');
    const mapped = req.prepareArgs({
      page: [page, optional(string())],
      size: [size, optional(number())],
      accountId: [accountId, optional(number())],
      usernamefragment: [usernamefragment, optional(string())],
      domainfragment: [domainfragment, optional(string())],
    });
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('accountId', mapped.accountId);
    req.query('usernamefragment', mapped.usernamefragment);
    req.query('domainfragment', mapped.domainfragment);
    return req.callAsXml(
      'SipCredentials',
      sipCredentialsSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param aggregatedusername
   * @return Response from the API call
   */
  async getSipCredential1(
    aggregatedusername: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipCredentials>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      aggregatedusername: [aggregatedusername, string()],
    });
    req.appendTemplatePath`/sipCredentials/${mapped.aggregatedusername}`;
    return req.callAsXml(
      'SipCredentials',
      sipCredentialsSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the current lock state of a site.
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async getSiteLock(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteLockResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/lock`;
    return req.callAsXml(
      'SiteLockResponse',
      siteLockResponseSchema,
      requestOptions
    );
  }

  /**
   * Modifies the lock state of a site.
   *
   * @param accountId
   * @param siteId
   * @param body
   * @return Response from the API call
   */
  async updateSiteLock(
    accountId: number,
    siteId: number,
    body?: SiteLock,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteLockResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.xml('body', body, 'Lock', optional(siteLockSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/lock`;
    req.throwOn(400, ApiError, 'The request to modify the site\'s locked state was invalid.');
    return req.callAsXml(
      'SiteLockResponse',
      siteLockResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId
   * @param body
   * @return Response from the API call
   */
  async createSiteLock(
    accountId: number,
    siteId: number,
    body?: SiteLock,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteLockResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.xml('body', body, 'Lock', optional(siteLockSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/lock`;
    return req.callAsXml(
      'SiteLockResponse',
      siteLockResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the current billing ID of a site.
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async getSiteBillingId(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteBillingIdResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/billingId`;
    return req.callAsXml(
      'SiteBillingIdResponse',
      siteBillingIdResponseSchema,
      requestOptions
    );
  }

  /**
   * Modifies the billing ID of a site.
   *
   * @param accountId
   * @param siteId
   * @param body
   * @return Response from the API call
   */
  async updateSiteBillingId(
    accountId: number,
    siteId: number,
    body?: SiteBillingId,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteBillingIdResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.xml('body', body, 'BillingId', optional(siteBillingIdSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/billingId`;
    req.throwOn(400, ApiError, 'The request to modify the site\'s billing ID was invalid.');
    return req.callAsXml(
      'SiteBillingIdResponse',
      siteBillingIdResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId
   * @param body
   * @return Response from the API call
   */
  async createSiteBillingId(
    accountId: number,
    siteId: number,
    body?: SiteBillingId,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteBillingIdResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.xml('body', body, 'BillingId', optional(siteBillingIdSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/billingId`;
    return req.callAsXml(
      'SiteBillingIdResponse',
      siteBillingIdResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async deleteSiteBillingId(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteBillingIdResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/billingId`;
    return req.callAsXml(
      'SiteBillingIdResponse',
      siteBillingIdResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the current billing ID of a site.
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async getSiteContract(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteContractResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/contract`;
    req.throwOn(404, ApiError, 'the billing ID does not exist');
    return req.callAsXml(
      'SiteContractResponse',
      siteContractResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates the contract of a site.
   *
   * @param accountId
   * @param siteId
   * @param body
   * @return Response from the API call
   */
  async updateSiteContract(
    accountId: number,
    siteId: number,
    body?: SiteContract,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteContractResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.xml('body', body, 'Contract', optional(siteContractSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/contract`;
    req.throwOn(400, ApiError, 'An HTTP 400 (BAD REQUEST) is returned if the request to modify the site\'s contract was invalid, e.g. the Contact Person is omitted.');
    return req.callAsXml(
      'SiteContractResponse',
      siteContractResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param siteId
   * @param body
   * @return Response from the API call
   */
  async createSiteContract(
    accountId: number,
    siteId: number,
    body?: SiteContract,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteContractResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.xml('body', body, 'Contract', optional(siteContractSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/contract`;
    return req.callAsXml(
      'SiteContractResponse',
      siteContractResponseSchema,
      requestOptions
    );
  }

  /**
   * Deletes the contract from a locked site.
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async deleteSiteContract(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteContractResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/contract`;
    req.throwOn(404, ApiError, 'An HTTP 404 (NOT FOUND) is returned if the site\'s contract does not exist');
    req.throwOn(408, ApiError, 'An HTTP 408 (CONFLICT) is returned if the request to modify the site\'s contract can not be completed in the site\'s current state. The site must be unlocked to perform this operation.');
    return req.callAsXml(
      'SiteContractResponse',
      siteContractResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.Some of the
   * important values that are established as part of this termination are described in the section on
   * POST.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateTerminationConfiguration(
    accountId: number,
    body?: AccountTerminationConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountTerminationConfigurationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationSettings',
      optional(accountTerminationConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the termination settings resource is incorrect.  The error contains an error code and description.');
    return req.callAsXml(
      'TerminationSettingResponse',
      accountTerminationConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.Some of the
   * important values that are established as part of this termination are...
   * <table><tr><th>parameter</th><th>description</th></tr><tr><td>RogerUsedForTerminationSettings</td><t
   * d>Boolean - a flag to indicate whether termination services are controlled by Roger or
   * not</td></tr><tr><td>LegacyTerminationSettings</td><td>a group encapsulating legacy termination
   * settings</td></tr><tr><td>ConcurrentOutboundCalls</td><td>integer</td></tr><tr><td>ConcurrentBidirec
   * tionalCalls</td><td>integer</td></tr><tr><td>CpsQueue</td><td>an integer value - typically
   * 300</td></tr><tr><td>CustomerTrafficAllowed</td><td>ALL, LITE, NONE and
   * DOMESTIC</td></tr><tr><td>RateType</td><td>npanxx, flat, fullcr or
   * billnumlcr</td></tr><tr><td>DiscountPercentage</td><td>an integer between 0 and
   * 100</td></tr><tr><td>GuaranteedTermination</td><td>true or
   * false</td></tr><tr><td>RogerTerminationSettings</td><td>a group encapsulating the new (undeveloped)
   * ROGER termination settings</td></tr><tr><td>SubnetAddressingAllowed</td><td>true or
   * false</td></tr></table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createTerminationConfiguration(
    accountId: number,
    body?: AccountTerminationConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountTerminationConfigurationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationSettings',
      optional(accountTerminationConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the termination settings resource is incorrect.  The error contains an error code and description.');
    return req.callAsXml(
      'TerminationSettingResponse',
      accountTerminationConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * get product and assignment mask for this product
   *
   * @param accountId
   * @param productId
   * @return Response from the API call
   */
  async getProductToAssign(
    accountId: number,
    productId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      productId: [productId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/product/${mapped.productId}/toassign`;
    req.throwOn(404, ApiError, 'assignment was not found');
    return req.callAsXml(
      'TerminationProductResponse',
      terminationProductResponseSchema,
      requestOptions
    );
  }

  /**
   * get assignment by product id
   *
   * @param accountId
   * @param productId
   * @return Response from the API call
   */
  async getAssignedProduct(
    accountId: number,
    productId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      productId: [productId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/product/${mapped.productId}`;
    req.throwOn(404, ApiError, 'product assignment was not found');
    return req.callAsXml(
      'TerminationCustomerProductAssignmentResponse',
      terminationCustomerProductAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * delete product assignment
   *
   * @param accountId
   * @param productId
   * @return Response from the API call
   */
  async deleteAssignedProduct(
    accountId: number,
    productId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      productId: [productId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/product/${mapped.productId}`;
    req.throwOn(400, ApiError, 'some required value was not found');
    req.throwOn(404, ApiError, 'account or attribute was not found');
    return req.callAsXml(
      'TerminationCustomerProductAssignmentResponse',
      terminationCustomerProductAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAllAssignedProducts(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/product`;
    return req.callAsXml(
      'TerminationCustomerProductAssignmentsResponse',
      terminationCustomerProductAssignmentsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateProduct(
    accountId: number,
    body?: TerminationProductAssignment,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationProductAssignment',
      optional(terminationProductAssignmentSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/product`;
    return req.callAsXml(
      'TerminationCustomerProductAssignmentResponse',
      terminationCustomerProductAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * assign product to customer
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createAssignProduct(
    accountId: number,
    body?: TerminationProductAssignment,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationProductAssignment',
      optional(terminationProductAssignmentSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/product`;
    req.throwOn(404, ApiError, 'specified in request account was not found');
    return req.callAsXml(
      'TerminationCustomerProductAssignmentResponse',
      terminationCustomerProductAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAssignedRateDecks(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/ratedeck`;
    return req.callAsXml(
      'TerminationRateDeckAssignmentsResponse',
      terminationRateDeckAssignmentsResponseSchema,
      requestOptions
    );
  }

  /**
   * assign rate deck to customer
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createAssignRateDeck(
    accountId: number,
    body?: TerminationRateDeckAssignment,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationRateDeckAssignment',
      optional(terminationRateDeckAssignmentSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/ratedeck`;
    req.throwOn(404, ApiError, 'account or ratedeck was not found');
    return req.callAsXml(
      'TerminationRateDeckAssignmentResponse',
      terminationRateDeckAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * get assignment by id
   *
   * @param accountId
   * @param assignmentId
   * @return Response from the API call
   */
  async getAssignedRateDeck(
    accountId: number,
    assignmentId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      assignmentId: [assignmentId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/ratedeck/${mapped.assignmentId}`;
    req.throwOn(404, ApiError, 'account or rate deck assignment was not found');
    return req.callAsXml(
      'TerminationRateDeckAssignmentResponse',
      terminationRateDeckAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * delete rate deck assignment
   *
   * @param accountId
   * @param assignmentId
   * @return Response from the API call
   */
  async deleteAssignedRateDeck(
    accountId: number,
    assignmentId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      assignmentId: [assignmentId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/ratedeck/${mapped.assignmentId}`;
    req.throwOn(404, ApiError, 'account or rate deck assignment was not found');
    return req.callAsXml(
      'TerminationRateDeckAssignmentResponse',
      terminationRateDeckAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * get all attributes for account
   *
   * @param accountId
   * @return Response from the API call
   */
  async getCustomerAttributes(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/attribute`;
    return req.callAsXml(
      'TerminationAttributesResponse',
      terminationAttributesResponseSchema,
      requestOptions
    );
  }

  /**
   * add to customer attribute
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async postCustomerAttribute(
    accountId: number,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/attribute`;
    req.throwOn(404, ApiError, 'specified in request account was not found');
    return req.callAsXml(
      'TerminationAttributeResponse',
      terminationAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * get account attribute by id
   *
   * @param accountId
   * @param attributeId
   * @return Response from the API call
   */
  async getCustomerAttribute(
    accountId: number,
    attributeId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      attributeId: [attributeId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/attribute/${mapped.attributeId}`;
    req.throwOn(404, ApiError, 'account or attribute was not found');
    return req.callAsXml(
      'TerminationAttributeResponse',
      terminationAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * update account attribute (attribute value)
   *
   * @param accountId
   * @param attributeId
   * @param body
   * @return Response from the API call
   */
  async putCustomerAttribute(
    accountId: number,
    attributeId: number,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      attributeId: [attributeId, number()],
    });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/attribute/${mapped.attributeId}`;
    req.throwOn(400, ApiError, 'update validation failed, eg changed forbidden fields (like metadata name)');
    req.throwOn(404, ApiError, 'account or attribute was not found');
    return req.callAsXml(
      'TerminationAttributeResponse',
      terminationAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * delete account attribute
   *
   * @param accountId
   * @param attributeId
   * @return Response from the API call
   */
  async deleteCustomerAttribute(
    accountId: number,
    attributeId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      attributeId: [attributeId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/attribute/${mapped.attributeId}`;
    req.throwOn(400, ApiError, 'some required value was not found');
    req.throwOn(404, ApiError, 'account or attribute was not found');
    return req.callAsXml(
      'TerminationAttributeResponse',
      terminationAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async postTerminationMigrate(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationMigrationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/termination/migrate`;
    return req.callAsXml(
      'TerminationMigrationResponse',
      terminationMigrationResponseSchema,
      requestOptions
    );
  }

  /**
   * Update Toll Free Settings for this account
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateTollFreeConfiguration(
    accountId: number,
    body?: TollFreeSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TollFreeSettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'TollFreeSettings', optional(tollFreeSettingsSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/tollfree/settings`;
    req.throwOn(400, ApiError, 'Failure to parse the request, or inconsistent provisioned data, such as no related product associated with the account.');
    return req.callAsXml(
      'TollFreeSettingsResponse',
      tollFreeSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves an account's trunk groups.
   *
   * @param accountId
   * @param status
   * @return Response from the API call
   */
  async getTrunkGroups(
    accountId: number,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TrunkGroupsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      status: [status, optional(string())],
    });
    req.query('status', mapped.status);
    req.appendTemplatePath`/accounts/${mapped.accountId}/trunkgroups`;
    return req.callAsXml(
      'TrunkGroupsResponse',
      trunkGroupsResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.Some of the
   * important values that are established as part of this UC Trunking are described in the section on
   * POST.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateUcTrunkingConfiguration(
    accountId: number,
    body?: UcTrunkingConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UcTrunkingConfigurationResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'UcTrunkingSettings',
      optional(ucTrunkingConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/uctrunking/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the UC Trunking settings resource is incorrect.  The error contains an error code and description.');
    return req.callAsXml(
      'UcTrunkingSettingsResponse',
      ucTrunkingConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * This resource can be PUT or POSTed to in order to establish the appropriate settings.
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createUcTrunkingConfiguration(
    accountId: number,
    body?: UcTrunkingConfigurationPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<UcTrunkingConfigurationResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'UcTrunkingSettings',
      optional(ucTrunkingConfigurationPayloadSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/products/uctrunking/settings`;
    req.throwOn(400, ApiError, 'a 400 BAD REQUEST will be returned with a descriptive payload if the XML describing the UC Trunking settings resource is incorrect.  The error contains an error code and description.');
    return req.callAsXml(
      'UcTrunkingSettingsResponse',
      ucTrunkingConfigurationResponseSchema,
      requestOptions
    );
  }

  /**
   * Updates the information for permission by unique permission name or creates permission, if it
   * doesn't exist.
   *
   * @param permissionId
   * @param domainName
   * @param permissions
   * @param body
   * @return Response from the API call
   */
  async updateLdapPermission(
    permissionId: string,
    domainName: string,
    permissions: string,
    body?: LdapPermission,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapPermissionResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      permissionId: [permissionId, string()],
      domainName: [domainName, string()],
      permissions: [permissions, string()],
    });
    req.xml('body', body, 'Permission', optional(ldapPermissionSchema));
    req.appendTemplatePath`/${mapped.permissionId}/${mapped.domainName}/${mapped.permissions}`;
    return req.callAsXml(
      'LdapPermissionResponse',
      ldapPermissionResponseSchema,
      requestOptions
    );
  }

  /**
   * Removes specified permission.
   *
   * @param permissionId
   * @param domainName
   * @param permissions
   * @return Response from the API call
   */
  async deleteLdapPermission(
    permissionId: string,
    domainName: string,
    permissions: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapPermissionResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      permissionId: [permissionId, string()],
      domainName: [domainName, string()],
      permissions: [permissions, string()],
    });
    req.appendTemplatePath`/${mapped.permissionId}/${mapped.domainName}/${mapped.permissions}`;
    req.throwOn(404, ApiError, 'The permission does not exist.');
    return req.callAsXml(
      'LdapPermissionResponse',
      ldapPermissionResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param domainName
   * @param userPreferences
   * @return Response from the API call
   */
  async getLdapUserPreferences(
    domainName: string,
    userPreferences: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserPreferencesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      domainName: [domainName, string()],
      userPreferences: [userPreferences, string()],
    });
    req.appendTemplatePath`/${mapped.domainName}/${mapped.userPreferences}`;
    return req.callAsXml(
      'UserPreferencesResponse',
      ldapUserPreferencesResponseSchema,
      requestOptions
    );
  }

  /**
   * Removing migrated user and all related information from LDAP.
   *
   * @param userId
   * @param domainName
   * @return Response from the API call
   */
  async deleteUser(
    userId: string,
    domainName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LdapUserResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      userId: [userId, string()],
      domainName: [domainName, string()],
    });
    req.appendTemplatePath`/${mapped.userId}/users/${mapped.domainName}`;
    req.throwOn(404, ApiError, 'User was not found.');
    return req.callAsXml(
      'LdapUserResponse',
      ldapUserResponseSchema,
      requestOptions
    );
  }

  /**
   * GET is used to retrieve all possible billing settings on account along with active ones.
   *
   * @param accountId
   * @return Response from the API call
   */
  async getSettings(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/billingsettings`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * PUT is used to update all billing settings on account. Ones which were previously stored but not
   * included in current payload will be removed. After PUT complete system will automatically send
   * backoffice API notification about billing settings change on account billing scope and all
   * subsequent scopes (sites, sippeers). Payload should follow the rules below. <table> <tr>
   * <th>Parameter</th> <th>Description</th> </tr> <tr> <td>BillingSettings</td> <td>Contains a list of
   * zero or more BillingSetting nodes</td> </tr> <tr> <td>BillingSetting</td> <td>Has one Key node and
   * one Values node</td> </tr> <tr> <td>Key</td> <td>Has one Id node and optional field Display</td>
   * </tr> <tr> <td>Values</td> <td>Has at least one Value node. List must contain one active Value
   * (Active node containing "True")</td> </tr> <tr> <td>Value</td> <td>Has one Id node and optional
   * field Display</td> </tr> <tr> <td>Display</td> <td>Optional field. Max length is 64 characters</td>
   * </tr> <tr> <td>Id</td> <td>Mandatory field. Max length is 64 characters</td> </tr> <tr>
   * <td>Active</td> <td>Optional field (see Values description though). Acceptable values True or
   * False</td> </tr> </table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateSettings(
    accountId: number,
    body?: BillingSettings,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<BillingSettingsResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'BillingSettings', optional(billingSettingsSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/billingsettings`;
    req.throwOn(400, ApiError, 'Bad request - in case of violation payload rules');
    return req.callAsXml(
      'BillingSettingsResponse',
      billingSettingsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the csr orders for the given account ID.<br>
   *
   * @param accountId
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param page
   * @param size
   * @param status
   * @return Response from the API call
   */
  async getAccountCsrOrders(
    accountId: number,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    page?: string,
    size?: number,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      page: [page, optional(string())],
      size: [size, optional(number())],
      status: [status, optional(string())],
    });
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('status', mapped.status);
    req.appendTemplatePath`/accounts/${mapped.accountId}/csrs`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieve a list of the E911 orders that are associated with the account. <p>A maximum of 1,000
   * orders can be retrieved per request. If no date range or specific query parameter (marked by <b
   * class="required">*</b> below) is provided, the order results will be limited to the last two years.
   * </p>
   *
   * @param accountId
   * @param status
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param activityState
   * @param bandwidthPrime
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param orderDetails      Example: false
   * @param orderIdFragment
   * @param includeInResponse
   * @param callBack
   * @param aeui
   * @param callingEndpoint
   * @return Response from the API call
   */
  async getE911Order2(
    accountId: number,
    status?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    orderDetails?: boolean,
    orderIdFragment?: string,
    includeInResponse?: string[],
    callBack?: string,
    aeui?: string,
    callingEndpoint?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      status: [status, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      orderDetails: [orderDetails, optional(boolean())],
      orderIdFragment: [orderIdFragment, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
      callBack: [callBack, optional(string())],
      aeui: [aeui, optional(string())],
      callingEndpoint: [callingEndpoint, optional(string())],
    });
    req.query('status', mapped.status);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('orderDetails', mapped.orderDetails);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('includeInResponse', mapped.includeInResponse);
    req.query('callBack', mapped.callBack);
    req.query('aeui', mapped.aeui);
    req.query('callingEndpoint', mapped.callingEndpoint);
    req.appendTemplatePath`/accounts/${mapped.accountId}/e911s`;
    req.throwOn(404, ApiError, 'Not Found. If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('E911OrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a specific assignedTns order identified as the resource.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrder1(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/numbersAssignment/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the identified TelephoneNumbersAssignment order id does not exist in the system');
    return req.callAsXml(
      'TelephoneNumbersAssignmentOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve information about one or more TelephoneNumbersAssignment orders, where the orders are
   * chosen based on the search parameters provided in the API Call.
   *
   * @param accountId
   * @param status
   * @param tn
   * @param customerOrderId
   * @param activityState
   * @param createdDateFrom
   * @param createdDateTo
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param orderIdFragment
   * @param action
   * @return Response from the API call
   */
  async getOrders1(
    accountId?: number[],
    status?: string[],
    tn?: string,
    customerOrderId?: string,
    activityState?: string[],
    createdDateFrom?: string,
    createdDateTo?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    orderIdFragment?: string,
    action?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/numbersAssignment');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      status: [status, optional(array(string()))],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      activityState: [activityState, optional(array(string()))],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      orderIdFragment: [orderIdFragment, optional(string())],
      action: [action, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('status', mapped.status);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('activityState', mapped.activityState);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('action', mapped.action);
    req.throwOn(400, ApiError, 'Bad Request.  If any errors are found in the processing of the query string a 400 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml(
      'TelephoneNumbersAssignmentOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @return Response from the API call
   */
  async deleteCleanUpBdrArchives(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('DELETE', '/bdrs/cleanup');
    return req.callAsXml(
      'BdrArchiveCleanUpResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve information about the hosts of account, as guided by optional search parameters.
   *
   * @param accountId
   * @param type
   * @param host
   * @return Response from the API call
   */
  async getHosts(
    accountId: number,
    type?: string,
    host?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountSitesHostsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      type: [type, optional(string())],
      host: [host, optional(string())],
    });
    req.query('type', mapped.type);
    req.query('host', mapped.host);
    req.appendTemplatePath`/accounts/${mapped.accountId}/hosts`;
    return req.callAsXml(
      'SiteHostsResponse',
      accountSitesHostsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getCsrOrderHistory(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/csrs/${mapped.orderId}/history`;
    return req.callAsXml('CsrOrderHistoryResponse', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param orderId
   * @return Response from the API call
   */
  async getLineOptionOrderHistory1(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/${mapped.orderId}/history`;
    return req.callAsXml(
      'TnOptionOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param orderId
   * @return Response from the API call
   */
  async getPortInOrderErrorHistory(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/${mapped.orderId}`;
    return req.callAsXml(
      'PortInOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve information about a specific DLDA Order identified as the resource.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getDldaOrder(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/dldas/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('DldaOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about one or more DLDA Orders (dldas), where the orders are chosen based on the
   * search parameters provided in the API Call. Not all search parameters are compatible with all other
   * search parameters, due to the complexity of searching for historical records using highly
   * parametrized or complex searches.  As a result:<ul>    <li>all query parameters are compatible with
   * the exception of...</li>    <li>if modifiedFromDate or modifiedToDate are specified, then the only
   * other valid search parameters is accountId</li></ul>
   *
   * @param accountId
   * @param status
   * @param orderIdFragment
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @return Response from the API call
   */
  async getDldaOrders(
    accountId?: number[],
    status?: string[],
    orderIdFragment?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/dldas');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      status: [status, optional(array(string()))],
      orderIdFragment: [orderIdFragment, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('status', mapped.status);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('DldaOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param orderId
   * @return Response from the API call
   */
  async getDldaOrderHistory1(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/dldas/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('DldaOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a E911 Order with specified ID.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getE911Order(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/e911s/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('E911OrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a specific E911 Order identified as the resource.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getE911Order1(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/e911s/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('E911OrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getE911OrderHistory(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/e911s/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('E911OrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param orderId
   * @return Response from the API call
   */
  async getE911OrderHistory1(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/e911s/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('E911OrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about one or more E911 Orders (e911s), where the orders are chosen based on the
   * search parameters provided in the API Call.Not all search parameters are compatible with all other
   * search parameters, due to the complexity of searching for historical records using highly
   * parameterized or complex searches.  As a result:<ul>            <li>all query parameters are
   * compatible with the exception of...</li>            <li>if modifiedFromDate or modifiedToDate are
   * specified, then the only other valid search parameters are accountId, sippeerId or siteId</li></ul>
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param status
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param activityState
   * @param bandwidthPrime
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param orderDetails          Example: false
   * @param orderIdFragment
   * @param includeInResponse
   * @param callBack
   * @param aeui
   * @param callingEndpoint
   * @return Response from the API call
   */
  async getE911Orders(
    accountId?: number[],
    invertAccountIdSearch?: boolean,
    status?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    orderDetails?: boolean,
    orderIdFragment?: string,
    includeInResponse?: string[],
    callBack?: string,
    aeui?: string,
    callingEndpoint?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/e911s');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      status: [status, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      orderDetails: [orderDetails, optional(boolean())],
      orderIdFragment: [orderIdFragment, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
      callBack: [callBack, optional(string())],
      aeui: [aeui, optional(string())],
      callingEndpoint: [callingEndpoint, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('status', mapped.status);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('orderDetails', mapped.orderDetails);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('includeInResponse', mapped.includeInResponse);
    req.query('callBack', mapped.callBack);
    req.query('aeui', mapped.aeui);
    req.query('callingEndpoint', mapped.callingEndpoint);
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('E911OrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a specific externalTns order identified as the resource.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrder3(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/externalTns/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the identified externalTns order id does not exist in the system');
    return req.callAsXml(
      'ExternalTnsOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve information about one or more externalTns orders, where the orders are chosen based on the
   * search parameters provided in the API Call.
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param status
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param activityState
   * @param bandwidthPrime
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param orderDetails          Example: false
   * @param orderIdFragment
   * @param action
   * @param type
   * @return Response from the API call
   */
  async getOrders3(
    accountId?: number[],
    invertAccountIdSearch?: boolean,
    status?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    orderDetails?: boolean,
    orderIdFragment?: string,
    action?: string,
    type?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/externalTns');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      status: [status, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      orderDetails: [orderDetails, optional(boolean())],
      orderIdFragment: [orderIdFragment, optional(string())],
      action: [action, optional(string())],
      type: [type, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('status', mapped.status);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('orderDetails', mapped.orderDetails);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('action', mapped.action);
    req.query('type', mapped.type);
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml(
      'ExternalTnsOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/externalTns/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml(
      'ExternalTnsOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve information about a importTnOrder with specified ID.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrder5(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/importtnorders/${mapped.orderId}`;
    return req.callAsXml(
      'ImportTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the importtnorders requests for the given account ID.
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param siteId
   * @param sippeerId
   * @param page
   * @param size
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param orderIdFragment
   * @param activityState
   * @param bandwidthPrime
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param includeInResponse
   * @param orderDetails          Example: false
   * @param status
   * @return Response from the API call
   */
  async getOrders5(
    accountId?: number[],
    invertAccountIdSearch?: boolean,
    siteId?: number,
    sippeerId?: number,
    page?: string,
    size?: number,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    orderIdFragment?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    includeInResponse?: string[],
    orderDetails?: boolean,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/importtnorders');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      page: [page, optional(string())],
      size: [size, optional(number())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      orderIdFragment: [orderIdFragment, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
      orderDetails: [orderDetails, optional(boolean())],
      status: [status, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('includeInResponse', mapped.includeInResponse);
    req.query('orderDetails', mapped.orderDetails);
    req.query('status', mapped.status);
    return req.callAsXml(
      'ImportTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the history of the specified importTnOrder.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory2(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/importtnorders/${mapped.orderId}/history`;
    return req.callAsXml(
      'ImportTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param orderId
   * @return Response from the API call
   */
  async getLidbOrderHistory(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/lidbs/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('LidbOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about one or more Lidb Orders (lidbs), where the orders are chosen based on the
   * search parameters provided in the API Call. Not all search parameters are compatible with all other
   * search parameters, due to the complexity of searching for historical records using highly
   * parameterize or complex searches.  As a result:<ul>     <li>all query parameters are compatible with
   * the exception of...</li>     <li>if modifiedFromDate or modifiedToDate are specified, then the only
   * other valid search parameters are accountId, sippeerId or siteId</li>     <li>sippeerId and siteId
   * are only compatible with searches that have a date range parameter.</li></ul>
   *
   * @param accountId
   * @param siteId
   * @param sippeerId
   * @param status
   * @param orderIdFragment
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @return Response from the API call
   */
  async getLidbOrders(
    accountId?: number[],
    siteId?: number,
    sippeerId?: number,
    status?: string[],
    orderIdFragment?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/lidbs');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      status: [status, optional(array(string()))],
      orderIdFragment: [orderIdFragment, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('status', mapped.status);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('LidbOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a specific Lidb Order identified as the resource.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getLidbOrder1(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/lidbs/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('LidbOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Create a LIDB order to associate Calling Name Information with a TN or list of CountOfTNsThe key
   * data elements in the submission are -    <table style="text-align: left; width: 80%;"     border="1"
   * cellpadding="2" cellspacing="2">      <tbody>        <tr>          <td>TelephoneNumbers</td>
   * <td>A list of telephone numbers that will all assume the SubscriberInformation that is listed in
   * the payload. In an enterprise context it is not uncommon for all of the served telephone numbers to
   * use the same string for the Subscriber Information.</td>        </tr>        <tr>
   * <td>SubscriberInformation</td>          <td>This is the field that is displayed to the user
   * receiving the phone call from the Telephone numbers in the TelephoneNumberList</td>        </tr>
   * <tr>          <td>UseType</td>          <td>Can be RESIDENTIAL or BUSINESS. The element is
   * required.</td>        </tr>        <tr>          <td>Visibility</td>          <td>Can be PRIVATE or
   * PUBLIC. If it is tagged as PRIVATE then the data will be provided, but the display will not be
   * provided on a standard phone call.  The element is required</td>        </tr>        <tr>
   * <td>CustomerOrderId</td>          <td>The Customer Order ID is an ID assigned by the account owner
   * to provide a reference number for the Order. The element is optional. Only alphanumeric values,
   * dashes and spaces are allowed. Max length is 40 characters.</td>        </tr>      </tbody>
   * </table>
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createLidbOrder(
    accountId: number,
    body?: LidbOrderPayload,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<LidbOrderResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml('body', body, 'LidbOrder', optional(lidbOrderPayloadSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/lidbs`;
    req.throwOn(400, ApiError, 'Bad RequestA 400 Bad Request indicates that the processing of the request payload has detected a syntactic error that prevents further processing.  No order is created under these conditions, and the request must be corrected and re-submitted before an order can be created.Error text and an error code will be provided in the ErrorList element.');
    return req.callAsXml(
      'LidbOrderResponse',
      lidbOrderResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve information about a TN Option Order with specified ID.
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getLineOptionOrder(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/tnoptions/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml(
      'TnOptionOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve a list of the TN Option orders that are associated with the account. <p>A maximum of 1,000
   * orders can be retrieved per request. If no date range or specific query parameter (marked by <b
   * class="required">*</b> below) is provided, the order results will be limited to the last two years.
   * </p>
   *
   * @param accountId
   * @param status
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param activityState
   * @param bandwidthPrime
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param orderDetails      Example: false
   * @param orderIdFragment
   * @param includeInResponse
   * @return Response from the API call
   */
  async getLineOptionOrder2(
    accountId: number,
    status?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    orderDetails?: boolean,
    orderIdFragment?: string,
    includeInResponse?: string[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      status: [status, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      orderDetails: [orderDetails, optional(boolean())],
      orderIdFragment: [orderIdFragment, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
    });
    req.query('status', mapped.status);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('orderDetails', mapped.orderDetails);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('includeInResponse', mapped.includeInResponse);
    req.appendTemplatePath`/accounts/${mapped.accountId}/tnoptions`;
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml(
      'TnOptionOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param accountId
   * @param orderId
   * @return Response from the API call
   */
  async getLineOptionOrderHistory(
    accountId: number,
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderId: [orderId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/tnoptions/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml(
      'TnOptionOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the information associated with the specified lsr ID number.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrder6(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/lsrorders/${mapped.orderId}`;
    return req.callAsXml('LsrOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about one or more Lsr orders, where the orders are chosen based on the search
   * parameters provided in the API Call.
   *
   * @param accountId
   * @param activityState
   * @param bandwidthPrime
   * @param createdDateFrom
   * @param createdDateTo
   * @param customerOrderId
   * @param includeInResponse
   * @param invertAccountIdSearch
   * @param lastModifiedAfter
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param orderIdFragment
   * @param status
   * @param tn
   * @param pon
   * @param btn
   * @param requestedFocDate
   * @param actualFocDate
   * @param lastModifiedBy
   * @return Response from the API call
   */
  async getOrders6(
    accountId?: number[],
    activityState?: string[],
    bandwidthPrime?: string[],
    createdDateFrom?: string,
    createdDateTo?: string,
    customerOrderId?: string,
    includeInResponse?: string[],
    invertAccountIdSearch?: boolean,
    lastModifiedAfter?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    orderIdFragment?: string,
    status?: string[],
    tn?: string,
    pon?: string,
    btn?: string,
    requestedFocDate?: string,
    actualFocDate?: string,
    lastModifiedBy?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/lsrorders');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      orderIdFragment: [orderIdFragment, optional(string())],
      status: [status, optional(array(string()))],
      tn: [tn, optional(string())],
      pon: [pon, optional(string())],
      btn: [btn, optional(string())],
      requestedFocDate: [requestedFocDate, optional(string())],
      actualFocDate: [actualFocDate, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('includeInResponse', mapped.includeInResponse);
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('status', mapped.status);
    req.query('tn', mapped.tn);
    req.query('pon', mapped.pon);
    req.query('btn', mapped.btn);
    req.query('requestedFocDate', mapped.requestedFocDate);
    req.query('actualFocDate', mapped.actualFocDate);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('LsrOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieves the history of the specified lsr order.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory4(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/lsrorders/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('LsrOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about one or more Port-in Orders (portins), where the orders are chosen based
   * on the search parameters provided in the API Call.
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param siteId
   * @param sippeerId
   * @param status
   * @param orderIdFragment
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param pon
   * @param btn
   * @param requestedFocDate
   * @param actualFocDate
   * @param customerOrderId
   * @param lastModifiedBy
   * @param activityState
   * @param bandwidthPrime
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param includeInResponse
   * @param bulkportinorderid
   * @return Response from the API call
   */
  async getPortInOrders(
    accountId?: number[],
    invertAccountIdSearch?: boolean,
    siteId?: number,
    sippeerId?: number,
    status?: string[],
    orderIdFragment?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    pon?: string,
    btn?: string,
    requestedFocDate?: string,
    actualFocDate?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    includeInResponse?: string[],
    bulkportinorderid?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/portins');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      status: [status, optional(array(string()))],
      orderIdFragment: [orderIdFragment, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      pon: [pon, optional(string())],
      btn: [btn, optional(string())],
      requestedFocDate: [requestedFocDate, optional(string())],
      actualFocDate: [actualFocDate, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
      bulkportinorderid: [bulkportinorderid, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('status', mapped.status);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('pon', mapped.pon);
    req.query('btn', mapped.btn);
    req.query('requestedFocDate', mapped.requestedFocDate);
    req.query('actualFocDate', mapped.actualFocDate);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('includeInResponse', mapped.includeInResponse);
    req.query('bulkportinorderid', mapped.bulkportinorderid);
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml(
      'PortInOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the information associated with the specified port-in ID number.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getPortInOrder(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/portins/${mapped.orderId}`;
    return req.callAsXml(
      'PortInOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the history of the specified port-in order.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getPortInOrderHistory(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/portins/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml(
      'PortInOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve information about one or more Port-Out Orders (portins), where the orders are chosen based
   * on the search parameters provided in the API Call. Not all search parameters are compatible with all
   * other search parameters, due to the complexity of searching for historical records using highly
   * parameterized or complex searches.  As a result:* all query parameters are compatible with the
   * exception of...** if modifiedFromDate or modifiedToDate are specified, then the only other valid
   * search parameters are accountId, sippeerId or siteId** sippeerId and siteId are only compatible with
   * searches that have a date range parameter.
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param orderIdFragment
   * @param status
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param requestedFocDate
   * @param actualFocDate
   * @param lastModifiedBy
   * @param activityState
   * @param bandwidthPrime
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param includeInResponse
   * @return Response from the API call
   */
  async getPortOutOrders(
    accountId?: number[],
    invertAccountIdSearch?: boolean,
    orderIdFragment?: string,
    status?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    requestedFocDate?: string,
    actualFocDate?: string,
    lastModifiedBy?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    includeInResponse?: string[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/portouts');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      orderIdFragment: [orderIdFragment, optional(string())],
      status: [status, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      requestedFocDate: [requestedFocDate, optional(string())],
      actualFocDate: [actualFocDate, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
    });
    req.query('accountId', mapped.accountId);
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('status', mapped.status);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('requestedFocDate', mapped.requestedFocDate);
    req.query('actualFocDate', mapped.actualFocDate);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('includeInResponse', mapped.includeInResponse);
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml(
      'PortOutOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the information associated with the specified port-out ID number.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getPortOutOrder(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/portouts/${mapped.orderId}`;
    return req.callAsXml(
      'PortOutOrderReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve information about a removeImportedTnOrder with specified ID.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrder10(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/removeImportedTnOrders/${mapped.orderId}`;
    return req.callAsXml(
      'RemoveImportedTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the removeImportedTnOrders requests for the given account ID.
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param siteId
   * @param sippeerId
   * @param page
   * @param size
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param orderIdFragment
   * @param activityState
   * @param bandwidthPrime
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param includeInResponse
   * @param orderDetails          Example: false
   * @param status
   * @return Response from the API call
   */
  async getOrders8(
    accountId?: number[],
    invertAccountIdSearch?: boolean,
    siteId?: number,
    sippeerId?: number,
    page?: string,
    size?: number,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    orderIdFragment?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    includeInResponse?: string[],
    orderDetails?: boolean,
    status?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/removeImportedTnOrders');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      page: [page, optional(string())],
      size: [size, optional(number())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      orderIdFragment: [orderIdFragment, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
      orderDetails: [orderDetails, optional(boolean())],
      status: [status, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('page', mapped.page);
    req.query('size', mapped.size);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('includeInResponse', mapped.includeInResponse);
    req.query('orderDetails', mapped.orderDetails);
    req.query('status', mapped.status);
    return req.callAsXml(
      'RemoveImportedTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieves the history of the specified removeImportedTnOrder.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getOrderHistory6(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/removeImportedTnOrders/${mapped.orderId}/history`;
    return req.callAsXml(
      'RemoveImportedTnOrdersReportResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * Retrieve the history information associated with an order
   *
   * @param orderId
   * @return Response from the API call
   */
  async getTnOrderHistory(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/orders/${mapped.orderId}/history`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about one or more New Number Orders (orders), where the orders are chosen based
   * on the search parameters provided in the API Call. Not all search parameters are compatible with all
   * other search parameters, due to the complexity of searching for historical records using highly
   * parameterized or complex searches.  As a result:* all query parameters are compatible with the
   * exception of...** if modifiedFromDate or modifiedToDate are specified, then the only other valid
   * search parameters are accountId, sippeerId or siteId** sippeerId and siteId are only compatible with
   * searches that have a date range parameter.
   *
   * @param accountId
   * @param invertAccountIdSearch
   * @param siteId
   * @param sippeerId
   * @param status
   * @param orderIdFragment
   * @param modifiedDateFrom
   * @param modifiedDateTo
   * @param tn
   * @param customerOrderId
   * @param lastModifiedBy
   * @param activityState
   * @param bandwidthPrime
   * @param lastModifiedAfter
   * @param createdDateFrom
   * @param createdDateTo
   * @param includeInResponse
   * @return Response from the API call
   */
  async getTnOrders(
    accountId?: number[],
    invertAccountIdSearch?: boolean,
    siteId?: number,
    sippeerId?: number,
    status?: string[],
    orderIdFragment?: string,
    modifiedDateFrom?: string,
    modifiedDateTo?: string,
    tn?: string,
    customerOrderId?: string,
    lastModifiedBy?: string,
    activityState?: string[],
    bandwidthPrime?: string[],
    lastModifiedAfter?: string,
    createdDateFrom?: string,
    createdDateTo?: string,
    includeInResponse?: string[],
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET', '/orders');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(array(number()))],
      invertAccountIdSearch: [invertAccountIdSearch, optional(boolean())],
      siteId: [siteId, optional(number())],
      sippeerId: [sippeerId, optional(number())],
      status: [status, optional(array(string()))],
      orderIdFragment: [orderIdFragment, optional(string())],
      modifiedDateFrom: [modifiedDateFrom, optional(string())],
      modifiedDateTo: [modifiedDateTo, optional(string())],
      tn: [tn, optional(string())],
      customerOrderId: [customerOrderId, optional(string())],
      lastModifiedBy: [lastModifiedBy, optional(string())],
      activityState: [activityState, optional(array(string()))],
      bandwidthPrime: [bandwidthPrime, optional(array(string()))],
      lastModifiedAfter: [lastModifiedAfter, optional(string())],
      createdDateFrom: [createdDateFrom, optional(string())],
      createdDateTo: [createdDateTo, optional(string())],
      includeInResponse: [includeInResponse, optional(array(string()))],
    });
    req.query('accountId', mapped.accountId);
    req.query('invertAccountIdSearch', mapped.invertAccountIdSearch);
    req.query('siteId', mapped.siteId);
    req.query('sippeerId', mapped.sippeerId);
    req.query('status', mapped.status);
    req.query('orderIdFragment', mapped.orderIdFragment);
    req.query('modifiedDateFrom', mapped.modifiedDateFrom);
    req.query('modifiedDateTo', mapped.modifiedDateTo);
    req.query('tn', mapped.tn);
    req.query('customerOrderId', mapped.customerOrderId);
    req.query('lastModifiedBy', mapped.lastModifiedBy);
    req.query('activityState', mapped.activityState);
    req.query('bandwidthPrime', mapped.bandwidthPrime);
    req.query('lastModifiedAfter', mapped.lastModifiedAfter);
    req.query('createdDateFrom', mapped.createdDateFrom);
    req.query('createdDateTo', mapped.createdDateTo);
    req.query('includeInResponse', mapped.includeInResponse);
    req.throwOn(404, ApiError, 'Not Found.  If any errors are found in the processing of the query string a 404 will be returned.  Note that parameters that are not recognized are not considered errors, and are just ignored.');
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve information about a specific New Number Order identified as the resource.
   *
   * @param orderId
   * @return Response from the API call
   */
  async getTnOrder(
    orderId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ orderId: [orderId, string()] });
    req.appendTemplatePath`/orders/${mapped.orderId}`;
    req.throwOn(404, ApiError, 'NOT FOUND - the order id does not exist in the system');
    return req.callAsXml('TnOrderReportResponse', unknown(), requestOptions);
  }

  /**
   * Retrieve count of Telephone numbers for the indicated site
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async getTotalTns(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteTnTotalResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/totaltns`;
    return req.callAsXml(
      'SiteTNsResponse',
      siteTnTotalResponseSchema,
      requestOptions
    );
  }

  /**
   * get a count of the available numbers on the system - structured in a variety of ways.
   *
   * @param type
   * @return Response from the API call
   */
  async getTelephoneNumbersDetailsHistory1(
    type?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumbersDetailsHistory>> {
    const req = this.createRequest('GET', '/availableNumbers');
    const mapped = req.prepareArgs({ type: [type, optional(string())] });
    req.query('type', mapped.type);
    req.throwOn(404, ApiError, 'Not Found - The search parameters are invalid and prevent finding any content');
    req.throwOn(500, ApiError, 'Internal Server Error - System error');
    req.throwOn(504, ApiError, 'Timeout - The system was not able to process your request in time');
    return req.callAsXml(
      'TNs',
      telephoneNumbersDetailsHistorySchema,
      requestOptions
    );
  }

  /**
   * Get the total number of available TNs filtered by the search parameters.
   *
   * @param tier
   * @param lata
   * @param rateCenter
   * @param areaCode
   * @param npaNxx
   * @param npaNxxx
   * @param state
   * @param city
   * @param startdate
   * @param enddate
   * @return Response from the API call
   */
  async getAvailableTelephoneNumberTotals(
    tier?: number,
    lata?: number,
    rateCenter?: string,
    areaCode?: string,
    npaNxx?: string,
    npaNxxx?: string,
    state?: string,
    city?: string,
    startdate?: string,
    enddate?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TelephoneNumberTotalsHistory>> {
    const req = this.createRequest('GET', '/availableNumbers/totals');
    const mapped = req.prepareArgs({
      tier: [tier, optional(number())],
      lata: [lata, optional(number())],
      rateCenter: [rateCenter, optional(string())],
      areaCode: [areaCode, optional(string())],
      npaNxx: [npaNxx, optional(string())],
      npaNxxx: [npaNxxx, optional(string())],
      state: [state, optional(string())],
      city: [city, optional(string())],
      startdate: [startdate, optional(string())],
      enddate: [enddate, optional(string())],
    });
    req.query('tier', mapped.tier);
    req.query('lata', mapped.lata);
    req.query('rateCenter', mapped.rateCenter);
    req.query('areaCode', mapped.areaCode);
    req.query('npaNxx', mapped.npaNxx);
    req.query('npaNxxx', mapped.npaNxxx);
    req.query('state', mapped.state);
    req.query('city', mapped.city);
    req.query('startdate', mapped.startdate);
    req.query('enddate', mapped.enddate);
    return req.callAsXml(
      'Quantity',
      telephoneNumberTotalsHistorySchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAccountTollFreeTotals1(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountTollFreeTotalsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/tftotals`;
    return req.callAsXml(
      'AccountTollFreeTotalsResponse',
      accountTollFreeTotalsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves the total count of Toll-Free Telephone Numbers for the given site.
   *
   * @param accountId
   * @param siteId
   * @return Response from the API call
   */
  async getSiteTollFreeTotals(
    accountId: number,
    siteId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SiteTollFreeTotalsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/tftotals`;
    return req.callAsXml(
      'SiteTollFreeTotalsResponse',
      siteTollFreeTotalsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param orderid
   * @param orderType
   * @param body
   * @return Response from the API call
   */
  async update(
    accountId: number,
    orderid: string,
    orderType: string,
    body?: InternalPortEvent,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderid: [orderid, string()],
      orderType: [orderType, string()],
    });
    req.xml(
      'body',
      body,
      'InternalPortEvent',
      optional(internalPortEventSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderid}/${mapped.orderType}/statusupdate`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the file associated with the order
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param fileName
   * @return Response from the API call
   */
  async getFile(
    accountId: number,
    orderType: string,
    orderId: string,
    fileName: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
      fileName: [fileName, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/loas/${mapped.fileName}`;
    req.throwOn(404, ApiError, 'a 404 indicates that the indicated file was not found in conjunction with the order id.');
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves the list of the loa (and other) files associated with the order
   *
   * @param accountId
   * @param orderType
   * @param orderId
   * @param metadata
   * @return Response from the API call
   */
  async getFilesForOrder(
    accountId: number,
    orderType: string,
    orderId: string,
    metadata?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<FileListResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      orderType: [orderType, string()],
      orderId: [orderId, string()],
      metadata: [metadata, optional(boolean())],
    });
    req.query('metadata', mapped.metadata);
    req.appendTemplatePath`/accounts/${mapped.accountId}/${mapped.orderType}/${mapped.orderId}/loas`;
    return req.callAsXml(
      'FileListResponse',
      fileListResponseSchema,
      requestOptions
    );
  }

  /**
   * A POST to the available orders API will add the listed TNs to the overall inventory, and create a
   * work-order that can be used to track the status of that attempt.Key data elements in the payload
   * include...* The account and gateway profile, that control the routing of calls that are placed to
   * these numbers.  The typical values are *UnallocatedNonTF* and *UnallocatedTF*.* The Vendor name that
   * will be associated with these numbers.  There must be allignment with the NPANXX of the numbers that
   * are being imported, and the Vendor that supplies the rate center in which the numbers will land.*
   * The list of telephone numbers themselves.
   *
   * @param body
   * @return Response from the API call
   */
  async createImportAvailableOrder(
    body?: ImportAvailableNumberOrder,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('POST', '/availableNumbers/orders');
    req.xml(
      'body',
      body,
      'ImportAvailableNumberOrder',
      optional(importAvailableNumberOrderSchema)
    );
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Retrieves an account's telephone number reservations
   *
   * @param accountId
   * @return Response from the API call
   */
  async getReservations(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReservationsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/accounts/${mapped.accountId}/TnReservation`;
    return req.callAsXml(
      'ReservationsResponse',
      reservationsResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieves reservation information associated with the Telephone Number.
   *
   * @param tn
   * @return Response from the API call
   */
  async getReservationByTn(
    tn: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReservationResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ tn: [tn, string()] });
    req.appendTemplatePath`/tns/${mapped.tn}/TnReservation`;
    return req.callAsXml(
      'ReservationResponse',
      reservationResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param region
   * @param abbreviation
   * @param vendor
   * @return Response from the API call
   */
  async getCoverage(
    region: string,
    abbreviation: string,
    vendor: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      region: [region, string()],
      abbreviation: [abbreviation, string()],
      vendor: [vendor, number()],
    });
    req.appendTemplatePath`/${mapped.region}/rateCenters/${mapped.abbreviation}/vendors/${mapped.vendor}/coverage`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param region
   * @param abbreviation
   * @param vendor
   * @param body
   * @return Response from the API call
   */
  async updateCoverage(
    region: string,
    abbreviation: string,
    vendor: number,
    body?: RateCenterCoverage,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      region: [region, string()],
      abbreviation: [abbreviation, string()],
      vendor: [vendor, number()],
      body: [body, optional(rateCenterCoverageSchema)],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/${mapped.region}/rateCenters/${mapped.abbreviation}/vendors/${mapped.vendor}/coverage`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param region
   * @param abbreviation
   * @return Response from the API call
   */
  async getRateCenter(
    region: string,
    abbreviation: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      region: [region, string()],
      abbreviation: [abbreviation, string()],
    });
    req.appendTemplatePath`/${mapped.region}/rateCenters/${mapped.abbreviation}`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param region
   * @return Response from the API call
   */
  async getRateCentersByRegion(
    region: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ region: [region, string()] });
    req.appendTemplatePath`/${mapped.region}/rateCenters`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * TODO
   *
   * @param region
   * @param abbreviation
   * @return Response from the API call
   */
  async getRateCenterCoverage(
    region: string,
    abbreviation: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      region: [region, string()],
      abbreviation: [abbreviation, string()],
    });
    req.appendTemplatePath`/${mapped.region}/rateCenters/${mapped.abbreviation}/coverage`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Get all report definitions
   *
   * @param scope
   * @param hidden Example: false
   * @return Response from the API call
   */
  async getReports(
    scope?: string,
    hidden?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportsResponse>> {
    const req = this.createRequest('GET', '/reports');
    const mapped = req.prepareArgs({
      scope: [scope, optional(string())],
      hidden: [hidden, optional(boolean())],
    });
    req.query('scope', mapped.scope);
    req.query('hidden', mapped.hidden);
    return req.callAsXml(
      'ReportsResponse',
      reportsResponseSchema,
      requestOptions
    );
  }

  /**
   * Creates a report type/definition
   *
   * @param body
   * @return Response from the API call
   */
  async createReport1(
    body?: Report,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportResponse>> {
    const req = this.createRequest('POST', '/reports');
    req.xml('body', body, 'Report', optional(reportSchema));
    return req.callAsXml(
      'ReportResponse',
      reportResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve report template details.
   *
   * @param reportId
   * @return Response from the API call
   */
  async getReport(
    reportId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ reportId: [reportId, number()] });
    req.appendTemplatePath`/reports/${mapped.reportId}`;
    req.throwOn(404, ApiError, 'A report template matching the provided ID could not be found.');
    return req.callAsXml(
      'ReportResponse',
      reportResponseSchema,
      requestOptions
    );
  }

  /**
   * Update an existing report template. Incorrect or omitted display priority will be replaced with the
   * default value of 1.
   *
   * @param reportId
   * @param body
   * @return Response from the API call
   */
  async updateReport(
    reportId: number,
    body?: Report,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ reportId: [reportId, number()] });
    req.xml('body', body, 'Report', optional(reportSchema));
    req.appendTemplatePath`/reports/${mapped.reportId}`;
    req.throwOn(404, ApiError, 'A report template matching the provided ID could not be found.');
    return req.callAsXml(
      'ReportResponse',
      reportResponseSchema,
      requestOptions
    );
  }

  /**
   * Delete an existing report template.
   *
   * @param reportId
   * @return Response from the API call
   */
  async deleteReport(
    reportId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ reportId: [reportId, number()] });
    req.appendTemplatePath`/reports/${mapped.reportId}`;
    req.throwOn(404, ApiError, 'A report template matching the provided ID could not be found.');
    return req.callAsXml(
      'ReportResponse',
      reportResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve report instances associated with a specific report, including the up-to-date report
   * generation status.
   *
   * @param reportId
   * @param accountId
   * @param userInstancesOnly
   * @return Response from the API call
   */
  async getReportInstances(
    reportId: number,
    accountId?: number,
    userInstancesOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstancesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      accountId: [accountId, optional(number())],
      userInstancesOnly: [userInstancesOnly, optional(boolean())],
    });
    req.query('accountId', mapped.accountId);
    req.query('userInstancesOnly', mapped.userInstancesOnly);
    req.appendTemplatePath`/reports/${mapped.reportId}/instances`;
    return req.callAsXml(
      'ReportInstancesResponse',
      reportInstancesResponseSchema,
      requestOptions
    );
  }

  /**
   * Create a new report instance for a specific report.
   *
   * @param reportId
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createReportInstance(
    reportId: number,
    accountId?: number,
    body?: ReportInstance,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstanceResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      accountId: [accountId, optional(number())],
    });
    req.query('accountId', mapped.accountId);
    req.xml('body', body, 'Instance', optional(reportInstanceSchema));
    req.appendTemplatePath`/reports/${mapped.reportId}/instances`;
    req.throwOn(400, ApiError, 'Bad Request');
    req.throwOn(503, ApiError, 'Service Unavailable');
    return req.callAsXml(
      'ReportInstanceResponse',
      reportInstanceResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param userInstancesOnly
   * @param scope
   * @return Response from the API call
   */
  async getInstances(
    accountId?: number,
    userInstancesOnly?: boolean,
    scope?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstancesResponse>> {
    const req = this.createRequest('GET', '/reports/instances');
    const mapped = req.prepareArgs({
      accountId: [accountId, optional(number())],
      userInstancesOnly: [userInstancesOnly, optional(boolean())],
      scope: [scope, optional(string())],
    });
    req.query('accountId', mapped.accountId);
    req.query('userInstancesOnly', mapped.userInstancesOnly);
    req.query('scope', mapped.scope);
    return req.callAsXml(
      'ReportInstancesResponse',
      reportInstancesResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve report instance details, including the current report instance status.
   *
   * @param reportId
   * @param reportInstanceId
   * @param accountId
   * @return Response from the API call
   */
  async getReportInstance(
    reportId: number,
    reportInstanceId: number,
    accountId?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstanceResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      reportInstanceId: [reportInstanceId, number()],
      accountId: [accountId, optional(number())],
    });
    req.query('accountId', mapped.accountId);
    req.appendTemplatePath`/reports/${mapped.reportId}/instances/${mapped.reportInstanceId}`;
    req.throwOn(404, ApiError, 'A report template matching the provided ID could not be found.');
    return req.callAsXml(
      'ReportInstanceResponse',
      reportInstanceResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param reportId
   * @param reportInstanceId
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async updateReportInstance(
    reportId: number,
    reportInstanceId: number,
    accountId?: number,
    body?: ReportInstance,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstanceResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      reportInstanceId: [reportInstanceId, number()],
      accountId: [accountId, optional(number())],
    });
    req.query('accountId', mapped.accountId);
    req.xml('body', body, 'Instance', optional(reportInstanceSchema));
    req.appendTemplatePath`/reports/${mapped.reportId}/instances/${mapped.reportInstanceId}`;
    return req.callAsXml(
      'ReportInstanceResponse',
      reportInstanceResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve report instance output file, if output is available.
   *
   * @param reportId
   * @param reportInstanceId
   * @param accountId
   * @return Response from the API call
   */
  async getReportInstanceFile(
    reportId: number,
    reportInstanceId: number,
    accountId?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      reportInstanceId: [reportInstanceId, number()],
      accountId: [accountId, optional(number())],
    });
    req.query('accountId', mapped.accountId);
    req.appendTemplatePath`/reports/${mapped.reportId}/instances/${mapped.reportInstanceId}/file`;
    req.throwOn(404, ApiError, 'A report instance matching the supplied identification information could not be found.');
    return req.callAsXml(
      'ReportInstanceFileResponse',
      unknown(),
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param reportId
   * @param reportInstanceId
   * @param accountId
   * @return Response from the API call
   */
  async deleteReportInstance(
    reportId: number,
    reportInstanceId: number,
    accountId?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ReportInstanceResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      reportId: [reportId, number()],
      reportInstanceId: [reportInstanceId, number()],
      accountId: [accountId, optional(number())],
    });
    req.query('accountId', mapped.accountId);
    req.appendTemplatePath`/${mapped.reportId}/instances/${mapped.reportInstanceId}`;
    return req.callAsXml(
      'ReportInstanceResponse',
      reportInstanceResponseSchema,
      requestOptions
    );
  }

  /**
   * Retrieve SBC settings associated with a Sip Peer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async getSipPeerEdgeManagementProducts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerEdgeManagementProductResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/edgemanagement`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>13563 "Sip Peer \'544545\' account \'12346159\' and site \'483\' does not exist"</li></ul>');
    req.throwOn(404, ApiError, 'Not Found - The SBC settings on Sip Peer does not exists');
    return req.callAsXml(
      'EdgeManagementResponse',
      sipPeerEdgeManagementProductResponseSchema,
      requestOptions
    );
  }

  /**
   * Update SBC setting to Sip Peer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async updateSipPeerEdgeManagementProducts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerEdgeManagementProduct,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerEdgeManagementProductResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'EdgeManagementProduct',
      optional(sipPeerEdgeManagementProductSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/edgemanagement`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>12041 "EdgeManagement product has not been configured"</li></ul>');
    return req.callAsXml(
      'EdgeManagementResponse',
      sipPeerEdgeManagementProductResponseSchema,
      requestOptions
    );
  }

  /**
   * Add SBC setting to Sip Peer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSipPeerEdgeManagementProducts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerEdgeManagementProduct,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerEdgeManagementProductResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml(
      'body',
      body,
      'EdgeManagementProduct',
      optional(sipPeerEdgeManagementProductSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/edgemanagement`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>12041 "EdgeManagement product has not been configured"</li></ul>');
    return req.callAsXml(
      'EdgeManagementResponse',
      sipPeerEdgeManagementProductResponseSchema,
      requestOptions
    );
  }

  /**
   * Delete SBC settings from Sip Peer
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @return Response from the API call
   */
  async deleteSipPeerEdgeManagementProducts(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerEdgeManagementProductResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/edgemanagement`;
    req.throwOn(400, ApiError, 'Bad Request. Possible errors in response:<ul>   <li>13563 "Sip Peer \'544545\' account \'12346159\' and site \'483\' does not exist"</li></ul>');
    return req.callAsXml(
      'EdgeManagementResponse',
      sipPeerEdgeManagementProductResponseSchema,
      requestOptions
    );
  }

  /**
   * post sip peer gateway IP or subnet
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSipPeerTerminationGateway2(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    body?: SipPeerGatewayIp,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayIpResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
    });
    req.xml('body', body, 'SipPeerGatewayIp', optional(sipPeerGatewayIpSchema));
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/termination/hosts`;
    return req.callAsXml(
      'SipPeerGatewayIpResponse',
      sipPeerGatewayIpResponseSchema,
      requestOptions
    );
  }

  /**
   * delete a sip peer gateway ip
   *
   * @param accountId
   * @param siteId
   * @param sipPeerId
   * @param gatewayId
   * @return Response from the API call
   */
  async deleteSipPeerTerminationGateway(
    accountId: number,
    siteId: number,
    sipPeerId: number,
    gatewayId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayIpResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      sipPeerId: [sipPeerId, number()],
      gatewayId: [gatewayId, number()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.sipPeerId}/products/termination/hosts/${mapped.gatewayId}`;
    req.throwOn(404, ApiError, 'sip peer gateway ip was not found');
    return req.callAsXml(
      'SipPeerGatewayIpResponse',
      sipPeerGatewayIpResponseSchema,
      requestOptions
    );
  }

  /**
   * post gateway attribute
   *
   * @param accountId
   * @param siteId
   * @param gatewayId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async createSipPeerTerminationGatewayAttribute(
    accountId: number,
    siteId: number,
    gatewayId: number,
    sipPeerId: string,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayAttributeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      gatewayId: [gatewayId, number()],
      sipPeerId: [sipPeerId, string()],
    });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.gatewayId}/products/termination/hosts/${mapped.sipPeerId}/settings`;
    return req.callAsXml(
      'SipPeerGatewayAttributeResponse',
      sipPeerGatewayAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * update gateway attribute
   *
   * @param accountId
   * @param siteId
   * @param gatewayId
   * @param attributeId
   * @param sipPeerId
   * @param body
   * @return Response from the API call
   */
  async updateSipPeerTerminationGatewayAttribute(
    accountId: number,
    siteId: number,
    gatewayId: number,
    attributeId: number,
    sipPeerId: string,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayAttributeResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      gatewayId: [gatewayId, number()],
      attributeId: [attributeId, number()],
      sipPeerId: [sipPeerId, string()],
    });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.gatewayId}/products/termination/hosts/${mapped.attributeId}/settings/${mapped.sipPeerId}`;
    return req.callAsXml(
      'SipPeerGatewayAttributeResponse',
      sipPeerGatewayAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * delete gateway attribute
   *
   * @param accountId
   * @param siteId
   * @param gatewayId
   * @param attributeId
   * @param sipPeerId
   * @return Response from the API call
   */
  async deleteSipPeerTerminationGatewayAttribute(
    accountId: number,
    siteId: number,
    gatewayId: number,
    attributeId: number,
    sipPeerId: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SipPeerGatewayAttributeResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      siteId: [siteId, number()],
      gatewayId: [gatewayId, number()],
      attributeId: [attributeId, number()],
      sipPeerId: [sipPeerId, string()],
    });
    req.appendTemplatePath`/accounts/${mapped.accountId}/sites/${mapped.siteId}/sippeers/${mapped.gatewayId}/products/termination/hosts/${mapped.attributeId}/settings/${mapped.sipPeerId}`;
    req.throwOn(404, ApiError, 'gateway attribute was not found');
    return req.callAsXml(
      'SipPeerGatewayAttributeResponse',
      sipPeerGatewayAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param productId
   * @return Response from the API call
   */
  async getAssignedProduct1(
    accountId: number,
    productId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      productId: [productId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/product/${mapped.productId}`;
    return req.callAsXml(
      'TerminationCustomerProductAssignmentResponse',
      terminationCustomerProductAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param productId
   * @return Response from the API call
   */
  async deleteAssignedProduct1(
    accountId: number,
    productId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      productId: [productId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/product/${mapped.productId}`;
    return req.callAsXml(
      'TerminationCustomerProductAssignmentResponse',
      terminationCustomerProductAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAssignedProducts(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/account/${mapped.accountId}/product`;
    return req.callAsXml(
      'TerminationCustomerProductAssignmentsResponse',
      terminationCustomerProductAssignmentsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async createAssignProduct1(
    accountId: number,
    body?: TerminationProductAssignment,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCustomerProductAssignmentResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationProductAssignment',
      optional(terminationProductAssignmentSchema)
    );
    req.appendTemplatePath`/account/${mapped.accountId}/product`;
    return req.callAsXml(
      'TerminationCustomerProductAssignmentResponse',
      terminationCustomerProductAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getCustomerAttributes1(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/account/${mapped.accountId}/attribute`;
    return req.callAsXml(
      'TerminationAttributesResponse',
      terminationAttributesResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async postCustomerAttribute1(
    accountId: number,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/account/${mapped.accountId}/attribute`;
    return req.callAsXml(
      'TerminationAttributeResponse',
      terminationAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param attributeId
   * @return Response from the API call
   */
  async getCustomerAttribute1(
    accountId: number,
    attributeId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      attributeId: [attributeId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/attribute/${mapped.attributeId}`;
    return req.callAsXml(
      'TerminationAttributeResponse',
      terminationAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param attributeId
   * @param body
   * @return Response from the API call
   */
  async putCustomerAttribute1(
    accountId: number,
    attributeId: number,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      attributeId: [attributeId, number()],
    });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/account/${mapped.accountId}/attribute/${mapped.attributeId}`;
    return req.callAsXml(
      'TerminationAttributeResponse',
      terminationAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param attributeId
   * @return Response from the API call
   */
  async deleteCustomerAttribute1(
    accountId: number,
    attributeId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      attributeId: [attributeId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/attribute/${mapped.attributeId}`;
    return req.callAsXml(
      'TerminationAttributeResponse',
      terminationAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * Get all products from term services.
   *
   * @return Response from the API call
   */
  async getTerminationProducts(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductsResponse>> {
    const req = this.createRequest('GET', '/product');
    return req.callAsXml(
      'TerminationProductsResponse',
      terminationProductsResponseSchema,
      requestOptions
    );
  }

  /**
   * create product
   *
   * @param body
   * @return Response from the API call
   */
  async postTerminationProduct(
    body?: TerminationProduct,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductResponse>> {
    const req = this.createRequest('POST', '/product');
    req.xml(
      'body',
      body,
      'TerminationProduct',
      optional(terminationProductSchema)
    );
    req.throwOn(400, ApiError, 'required fields are absent, attribute list is not empty');
    return req.callAsXml(
      'TerminationProductResponse',
      terminationProductResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param gatewayId
   * @return Response from the API call
   */
  async getGatewayAttributes(
    accountId: number,
    gatewayId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewayAttributesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      gatewayId: [gatewayId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/gateway/${mapped.gatewayId}/attribute`;
    return req.callAsXml(
      'TerminationGatewayAttributesResponse',
      terminationGatewayAttributesResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param gatewayId
   * @param body
   * @return Response from the API call
   */
  async postGatewayAttribute(
    accountId: number,
    gatewayId: number,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewayAttributeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      gatewayId: [gatewayId, number()],
    });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/account/${mapped.accountId}/gateway/${mapped.gatewayId}/attribute`;
    return req.callAsXml(
      'TerminationGatewayAttributeResponse',
      terminationGatewayAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param gatewayId
   * @param attributeId
   * @return Response from the API call
   */
  async getGatewayAttribute(
    accountId: number,
    gatewayId: number,
    attributeId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewayAttributeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      gatewayId: [gatewayId, number()],
      attributeId: [attributeId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/gateway/${mapped.gatewayId}/attribute/${mapped.attributeId}`;
    return req.callAsXml(
      'TerminationGatewayAttributeResponse',
      terminationGatewayAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param gatewayId
   * @param attributeId
   * @param body
   * @return Response from the API call
   */
  async putGatewayAttribute(
    accountId: number,
    gatewayId: number,
    attributeId: number,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewayAttributeResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      gatewayId: [gatewayId, number()],
      attributeId: [attributeId, number()],
    });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/account/${mapped.accountId}/gateway/${mapped.gatewayId}/attribute/${mapped.attributeId}`;
    return req.callAsXml(
      'TerminationGatewayAttributeResponse',
      terminationGatewayAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param gatewayId
   * @param attributeId
   * @return Response from the API call
   */
  async deleteGatewayAttribute(
    accountId: number,
    gatewayId: number,
    attributeId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewayAttributeResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      gatewayId: [gatewayId, number()],
      attributeId: [attributeId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/gateway/${mapped.gatewayId}/attribute/${mapped.attributeId}`;
    return req.callAsXml(
      'TerminationGatewayAttributeResponse',
      terminationGatewayAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * This API allow get a list of all available carrier names from Roger.
   *
   * @return Response from the API call
   */
  async getTerminationCarriers(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarriersResponse>> {
    const req = this.createRequest('GET', '/carrier');
    req.throwOn(500, ApiError, 'Server Error');
    return req.callAsXml(
      'TerminationCarriersResponse',
      terminationCarriersResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @return Response from the API call
   */
  async getTerminationTollFreeCarriers(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarriersResponse>> {
    const req = this.createRequest('GET', '/tollFreeCarriers');
    return req.callAsXml(
      'TerminationCarriersResponse',
      terminationCarriersResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @return Response from the API call
   */
  async getTerminationAccounts(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AccountsResponse>> {
    const req = this.createRequest('GET', '/account');
    return req.callAsXml(
      'AccountsResponse',
      accountsResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param body
   * @return Response from the API call
   */
  async postTerminationAccount(
    body?: TerminationAccount,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAccountResponse>> {
    const req = this.createRequest('POST', '/account');
    req.xml(
      'body',
      body,
      'TerminationAccount',
      optional(terminationAccountSchema)
    );
    return req.callAsXml(
      'TerminationAccountResponse',
      terminationAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getTerminationAccount(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAccountResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/account/${mapped.accountId}`;
    return req.callAsXml(
      'TerminationAccountResponse',
      terminationAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async deleteTerminationAccount(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/account/${mapped.accountId}`;
    return req.callAsXml(
      'TerminationProductResponse',
      terminationProductResponseSchema,
      requestOptions
    );
  }

  /**
   * Get termination product by id.
   *
   * @param productId
   * @param toAssign
   * @return Response from the API call
   */
  async getTerminationProduct(
    productId: number,
    toAssign?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      productId: [productId, number()],
      toAssign: [toAssign, optional(boolean())],
    });
    req.query('toAssign', mapped.toAssign);
    req.appendTemplatePath`/product/${mapped.productId}`;
    req.throwOn(404, ApiError, 'Could not find product by id.');
    req.throwOn(500, ApiError, 'System error.');
    return req.callAsXml(
      'TerminationProductResponse',
      terminationProductResponseSchema,
      requestOptions
    );
  }

  /**
   * Delete termination product by id.
   *
   * @param productId
   * @return Response from the API call
   */
  async deleteTerminationProduct(
    productId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ productId: [productId, number()] });
    req.appendTemplatePath`/product/${mapped.productId}`;
    req.throwOn(404, ApiError, 'Could not find product by id.');
    req.throwOn(500, ApiError, 'System error.');
    return req.callAsXml(
      'TerminationProductResponse',
      terminationProductResponseSchema,
      requestOptions
    );
  }

  /**
   * Get all product attributes
   *
   * @param productId
   * @return Response from the API call
   */
  async getTerminationProductAttributes(
    productId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductAttributesResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ productId: [productId, number()] });
    req.appendTemplatePath`/product/${mapped.productId}/attribute`;
    return req.callAsXml(
      'TerminationProductAttributesResponse',
      terminationProductAttributesResponseSchema,
      requestOptions
    );
  }

  /**
   * create product attribute
   *
   * @param productId
   * @param body
   * @return Response from the API call
   */
  async postTerminationProductAttribute(
    productId: number,
    body?: TerminationAttribute,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductAttributeResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ productId: [productId, number()] });
    req.xml(
      'body',
      body,
      'TerminationAttribute',
      optional(terminationAttributeSchema)
    );
    req.appendTemplatePath`/product/${mapped.productId}/attribute`;
    return req.callAsXml(
      'TerminationProductAttributeResponse',
      terminationProductAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * Get all product attribute by id
   *
   * @param productId
   * @param attributeId
   * @return Response from the API call
   */
  async getTerminationProductAttribute(
    productId: number,
    attributeId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductAttributeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      productId: [productId, number()],
      attributeId: [attributeId, number()],
    });
    req.appendTemplatePath`/product/${mapped.productId}/attribute/${mapped.attributeId}`;
    return req.callAsXml(
      'TerminationProductAttributeResponse',
      terminationProductAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param productId
   * @param attributeId
   * @return Response from the API call
   */
  async deleteTerminationProductAttribute(
    productId: number,
    attributeId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationProductAttributeResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      productId: [productId, number()],
      attributeId: [attributeId, number()],
    });
    req.appendTemplatePath`/product/${mapped.productId}/attribute/${mapped.attributeId}`;
    return req.callAsXml(
      'TerminationProductAttributeResponse',
      terminationProductAttributeResponseSchema,
      requestOptions
    );
  }

  /**
   * Get rate deck metadata by id.
   *
   * @param deckId
   * @return Response from the API call
   */
  async getRateDecksMetadata(
    deckId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckMetadataResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ deckId: [deckId, number()] });
    req.appendTemplatePath`/ratedeck/${mapped.deckId}`;
    return req.callAsXml(
      'TerminationRateDeckMetadataResponse',
      terminationRateDeckMetadataResponseSchema,
      requestOptions
    );
  }

  /**
   * Delete rate deck by id.
   *
   * @param deckId
   * @return Response from the API call
   */
  async deleteRateDeck(
    deckId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ deckId: [deckId, number()] });
    req.appendTemplatePath`/ratedeck/${mapped.deckId}`;
    return req.callAsXml(
      'TerminationRateDeckResponse',
      terminationRateDeckResponseSchema,
      requestOptions
    );
  }

  /**
   * Get all rate decks by type
   *
   * @param deckType
   * @return Response from the API call
   */
  async getRateDecksMetadata1(
    deckType: DeckTypeEnum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckMetadataByTypeResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      deckType: [deckType, deckTypeEnumSchema],
    });
    req.appendTemplatePath`/ratedeck/type/${mapped.deckType}`;
    return req.callAsXml(
      'TerminationRateDeckMetadataByTypeResponse',
      terminationRateDeckMetadataByTypeResponseSchema,
      requestOptions
    );
  }

  /**
   * Get all rate deck metadata
   *
   * @return Response from the API call
   */
  async getRateDecksMetadata2(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckMetadatasResponse>> {
    const req = this.createRequest('GET', '/ratedeck');
    return req.callAsXml(
      'TerminationRateDeckMetadatasResponse',
      terminationRateDeckMetadatasResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param deckId
   * @param filetype
   * @return Response from the API call
   */
  async getDownloadRateDeck(
    deckId: number,
    filetype?: FiletypeEnum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      deckId: [deckId, number()],
      filetype: [filetype, optional(filetypeEnumSchema)],
    });
    req.query('filetype', mapped.filetype);
    req.appendTemplatePath`/ratedeck/${mapped.deckId}/file`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Upload rate deck file
   *
   * @param fileName
   * @param rateDeckName
   * @param body
   * @return Response from the API call
   */
  async postRateDeck(
    fileName: string,
    rateDeckName: string,
    body?: unknown,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      fileName: [fileName, string()],
      rateDeckName: [rateDeckName, string()],
      body: [body, optional(unknown())],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/ratedeck/file/${mapped.fileName}/${mapped.rateDeckName}`;
    return req.callAsXml(
      'TerminationRateDeckResponse',
      terminationRateDeckResponseSchema,
      requestOptions
    );
  }

  /**
   * Get all rate deck assignments
   *
   * @param assignmentId
   * @return Response from the API call
   */
  async getRateDeckAssignment(
    assignmentId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentUtilityResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ assignmentId: [assignmentId, number()] });
    req.appendTemplatePath`/ratedeckassignment/${mapped.assignmentId}`;
    return req.callAsXml(
      'TerminationRateDeckAssignmentUtilityResponse',
      terminationRateDeckAssignmentUtilityResponseSchema,
      requestOptions
    );
  }

  /**
   * Get termination product by id.
   *
   * @param accountId
   * @param assignmentId
   * @return Response from the API call
   */
  async getRateDeckAssignmentForAccount(
    accountId: number,
    assignmentId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      assignmentId: [assignmentId, number()],
    });
    req.appendTemplatePath`/ratedeckassignment/${mapped.accountId}/account/${mapped.assignmentId}`;
    return req.callAsXml(
      'TerminationRateDeckAssignmentResponse',
      terminationRateDeckAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * Unassign rate deck by assignment id.
   *
   * @param accountId
   * @param assignmentId
   * @return Response from the API call
   */
  async deleteRateDeckAssignmentForAccount(
    accountId: number,
    assignmentId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      assignmentId: [assignmentId, number()],
    });
    req.appendTemplatePath`/ratedeckassignment/${mapped.accountId}/account/${mapped.assignmentId}`;
    req.throwOn(404, ApiError, 'Could not find assignment by id.');
    req.throwOn(500, ApiError, 'System error.');
    return req.callAsXml(
      'TerminationRateDeckAssignmentResponse',
      terminationRateDeckAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * Get all rate deck assignments
   *
   * @return Response from the API call
   */
  async getAllRateDeckAssignments(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentsUtilityResponse>> {
    const req = this.createRequest('GET', '/ratedeckassignment');
    return req.callAsXml(
      'TerminationRateDeckAssignmentsUtilityResponse',
      terminationRateDeckAssignmentsUtilityResponseSchema,
      requestOptions
    );
  }

  /**
   * assign rate deck
   *
   * @param body
   * @return Response from the API call
   */
  async postRateDeckAssignmentForAccount(
    body?: TerminationRateDeckAssignment,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentResponse>> {
    const req = this.createRequest('POST', '/ratedeckassignment');
    req.xml(
      'body',
      body,
      'TerminationRateDeckAssignment',
      optional(terminationRateDeckAssignmentSchema)
    );
    return req.callAsXml(
      'TerminationRateDeckAssignmentResponse',
      terminationRateDeckAssignmentResponseSchema,
      requestOptions
    );
  }

  /**
   * Get all rate deck assignments
   *
   * @param accountId
   * @return Response from the API call
   */
  async getAllRateDeckAssignmentsForAccount(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRateDeckAssignmentsResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/ratedeckassignment/account/${mapped.accountId}`;
    return req.callAsXml(
      'TerminationRateDeckAssignmentsResponse',
      terminationRateDeckAssignmentsResponseSchema,
      requestOptions
    );
  }

  /**
   * get all attribute metadata
   *
   * @return Response from the API call
   */
  async getTerminationAttributeMetadatas(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeMetadatasResponse>> {
    const req = this.createRequest('GET', '/attributes');
    return req.callAsXml(
      'TerminationAttributeMetadatasResponse',
      terminationAttributeMetadatasResponseSchema,
      requestOptions
    );
  }

  /**
   * post attribute metadata
   *
   * @param body
   * @return Response from the API call
   */
  async postTerminationAttributeMetadata(
    body?: TerminationAttributeMetadata,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeMetadataResponse>> {
    const req = this.createRequest('POST', '/attributes');
    req.xml(
      'body',
      body,
      'TerminationAttributeMetadata',
      optional(terminationAttributeMetadataSchema)
    );
    return req.callAsXml(
      'TerminationAttributeMetadataResponse',
      terminationAttributeMetadataResponseSchema,
      requestOptions
    );
  }

  /**
   * get all attributes by origin
   *
   * @param origin
   * @return Response from the API call
   */
  async getTerminationAttributeMetadatasByOrigin(
    origin?: OriginEnum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeMetadataByOriginResponse>> {
    const req = this.createRequest('GET', '/attributes/origin');
    const mapped = req.prepareArgs({
      origin: [origin, optional(originEnumSchema)],
    });
    req.query('origin', mapped.origin);
    return req.callAsXml(
      'TerminationAttributeMetadataByOriginResponse',
      terminationAttributeMetadataByOriginResponseSchema,
      requestOptions
    );
  }

  /**
   * get all attributes by type
   *
   * @param type
   * @return Response from the API call
   */
  async getTerminationAttributeMetadatasByType(
    type?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeMetadataByNameResponse>> {
    const req = this.createRequest('GET', '/attributes/type');
    const mapped = req.prepareArgs({ type: [type, optional(string())] });
    req.query('type', mapped.type);
    return req.callAsXml(
      'TerminationAttributeMetadataByNameResponse',
      terminationAttributeMetadataByNameResponseSchema,
      requestOptions
    );
  }

  /**
   * get account by id
   *
   * @param id
   * @return Response from the API call
   */
  async getTerminationAttributeMetadataById(
    id: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeMetadataResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, number()] });
    req.appendTemplatePath`/attributes/${mapped.id}`;
    return req.callAsXml(
      'TerminationAttributeMetadataResponse',
      terminationAttributeMetadataResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param id
   * @param body
   * @return Response from the API call
   */
  async putTerminationAttributeMetadata(
    id: number,
    body?: TerminationAttributeMetadata,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationAttributeMetadataResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({ id: [id, number()] });
    req.xml(
      'body',
      body,
      'TerminationAttributeMetadata',
      optional(terminationAttributeMetadataSchema)
    );
    req.appendTemplatePath`/attributes/${mapped.id}`;
    return req.callAsXml(
      'TerminationAttributeMetadataResponse',
      terminationAttributeMetadataResponseSchema,
      requestOptions
    );
  }

  /**
   * Get list of named Carrier Masks from Roger
   *
   * @return Response from the API call
   */
  async getCarrierMasks(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarrierMasksResponse>> {
    const req = this.createRequest('GET', '/carriermask');
    req.throwOn(500, ApiError, 'Server Error');
    return req.callAsXml(
      'TerminationCarrierMasksResponse',
      terminationCarrierMasksResponseSchema,
      requestOptions
    );
  }

  /**
   * Update carrier mask
   *
   * @param body
   * @return Response from the API call
   */
  async updateCarrierMask(
    body?: TerminationCarrierMask,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarrierMaskResponse>> {
    const req = this.createRequest('PUT', '/carriermask');
    req.xml(
      'body',
      body,
      'TerminationCarrierMask',
      optional(terminationCarrierMaskSchema)
    );
    return req.callAsXml(
      'TerminationCarrierMaskResponse',
      terminationCarrierMaskResponseSchema,
      requestOptions
    );
  }

  /**
   * Create a carrier mask
   *
   * @param body
   * @return Response from the API call
   */
  async createCarrierMask(
    body?: TerminationCarrierMask,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarrierMaskResponse>> {
    const req = this.createRequest('POST', '/carriermask');
    req.xml(
      'body',
      body,
      'TerminationCarrierMask',
      optional(terminationCarrierMaskSchema)
    );
    req.throwOn(500, ApiError, 'It may happen in many cases, e.g. such carrier mask name already exists');
    return req.callAsXml(
      'TerminationCarrierMaskResponse',
      terminationCarrierMaskResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param maskId
   * @return Response from the API call
   */
  async getCarrierMask(
    maskId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarrierMaskResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ maskId: [maskId, number()] });
    req.appendTemplatePath`/carriermask/${mapped.maskId}`;
    return req.callAsXml(
      'TerminationCarrierMaskResponse',
      terminationCarrierMaskResponseSchema,
      requestOptions
    );
  }

  /**
   * Delete carrier mask by id
   *
   * @param maskId
   * @return Response from the API call
   */
  async deleteCarrierMask(
    maskId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarrierMaskResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ maskId: [maskId, number()] });
    req.appendTemplatePath`/carriermask/${mapped.maskId}`;
    return req.callAsXml(
      'TerminationCarrierMaskResponse',
      terminationCarrierMaskResponseSchema,
      requestOptions
    );
  }

  /**
   * Get list of carrier mask metadata
   *
   * @return Response from the API call
   */
  async getCarrierMaskMetadatas(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarrierMaskMetadatasResponse>> {
    const req = this.createRequest('GET', '/carriermask/metadata');
    return req.callAsXml(
      'TerminationCarrierMaskMetadatasResponse',
      terminationCarrierMaskMetadatasResponseSchema,
      requestOptions
    );
  }

  /**
   * Get carrier mask by specified id
   *
   * @param maskId
   * @return Response from the API call
   */
  async getCarrierMaskMetadata(
    maskId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarrierMaskMetadataResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ maskId: [maskId, number()] });
    req.appendTemplatePath`/carriermask/metadata/${mapped.maskId}`;
    return req.callAsXml(
      'TerminationCarrierMaskMetadataResponse',
      terminationCarrierMaskMetadataResponseSchema,
      requestOptions
    );
  }

  /**
   * Get carrier mask by specified carrier mask name
   *
   * @param queryName
   * @return Response from the API call
   */
  async searchCarrierMaskMetadata(
    queryName?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationCarrierMaskMetadataSearchResponse>> {
    const req = this.createRequest('GET', '/carriermask/metadata/search');
    const mapped = req.prepareArgs({
      queryName: [queryName, optional(string())],
    });
    req.query('query_name', mapped.queryName);
    return req.callAsXml(
      'TerminationCarrierMaskMetadataSearchResponse',
      terminationCarrierMaskMetadataSearchResponseSchema,
      requestOptions
    );
  }

  /**
   * Upload carrier mask file
   *
   * @param fileName
   * @param carrierMaskName
   * @param carrierMaskType
   * @param body
   * @return Response from the API call
   */
  async postCarrierMaskFile(
    fileName: string,
    carrierMaskName: string,
    carrierMaskType: string,
    body?: unknown,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CarrierMaskFileResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      fileName: [fileName, string()],
      carrierMaskName: [carrierMaskName, string()],
      carrierMaskType: [carrierMaskType, string()],
      body: [body, optional(unknown())],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/carriermask/file/${mapped.fileName}/${mapped.carrierMaskName}/${mapped.carrierMaskType}`;
    return req.callAsXml(
      'CarrierMaskFileResponse',
      carrierMaskFileResponseSchema,
      requestOptions
    );
  }

  /**
   * Get list of named Routing Exceptions from Roger
   *
   * @return Response from the API call
   */
  async getRoutingExceptions(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionsResponse>> {
    const req = this.createRequest('GET', '/routingexception');
    req.throwOn(500, ApiError, 'Server Error');
    return req.callAsXml(
      'TerminationRoutingExceptionsResponse',
      terminationRoutingExceptionsResponseSchema,
      requestOptions
    );
  }

  /**
   * update routing exception
   *
   * @param body
   * @return Response from the API call
   */
  async updateRoutingException(
    body?: TerminationRoutingException,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionResponse>> {
    const req = this.createRequest('PUT', '/routingexception');
    req.xml(
      'body',
      body,
      'TerminationRoutingException',
      optional(terminationRoutingExceptionSchema)
    );
    return req.callAsXml(
      'TerminationRoutingExceptionResponse',
      terminationRoutingExceptionResponseSchema,
      requestOptions
    );
  }

  /**
   * Create a routing exception
   *
   * @param body
   * @return Response from the API call
   */
  async createRoutingException(
    body?: TerminationRoutingException,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionResponse>> {
    const req = this.createRequest('POST', '/routingexception');
    req.xml(
      'body',
      body,
      'TerminationRoutingException',
      optional(terminationRoutingExceptionSchema)
    );
    req.throwOn(500, ApiError, 'It may happen in many cases, e.g. such routing exception name already exists');
    return req.callAsXml(
      'TerminationRoutingExceptionResponse',
      terminationRoutingExceptionResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param id
   * @return Response from the API call
   */
  async getRoutingException(
    id: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, number()] });
    req.appendTemplatePath`/routingexception/${mapped.id}`;
    return req.callAsXml(
      'TerminationRoutingExceptionResponse',
      terminationRoutingExceptionResponseSchema,
      requestOptions
    );
  }

  /**
   * delete routing exception by id
   *
   * @param id
   * @return Response from the API call
   */
  async deleteRoutingException(
    id: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, number()] });
    req.appendTemplatePath`/routingexception/${mapped.id}`;
    return req.callAsXml(
      'TerminationRoutingExceptionResponse',
      terminationRoutingExceptionResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param id
   * @return Response from the API call
   */
  async getRoutingExceptionFile(
    id: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, number()] });
    req.appendTemplatePath`/routingexception/${mapped.id}/file`;
    return req.callAsXml('response', unknown(), requestOptions);
  }

  /**
   * Upload routing exception file
   *
   * @param fileName
   * @param routingExceptionName
   * @param body
   * @return Response from the API call
   */
  async postRoutingExceptionFile(
    fileName: string,
    routingExceptionName: string,
    body?: unknown,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionFileResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      fileName: [fileName, string()],
      routingExceptionName: [routingExceptionName, string()],
      body: [body, optional(unknown())],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/routingexception/file/${mapped.fileName}/${mapped.routingExceptionName}`;
    return req.callAsXml(
      'TerminationRoutingExceptionFileResponse',
      terminationRoutingExceptionFileResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param id
   * @param fileName
   * @param routingExceptionName
   * @param body
   * @return Response from the API call
   */
  async updatePostRoutingExceptionFile1(
    id: number,
    fileName: string,
    routingExceptionName: string,
    body?: unknown,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionFileResponse>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, number()],
      fileName: [fileName, string()],
      routingExceptionName: [routingExceptionName, string()],
      body: [body, optional(unknown())],
    });
    req.json(mapped.body);
    req.appendTemplatePath`/routingexception/${mapped.id}/file/${mapped.fileName}/${mapped.routingExceptionName}`;
    return req.callAsXml(
      'TerminationRoutingExceptionFileResponse',
      terminationRoutingExceptionFileResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @return Response from the API call
   */
  async getRoutingExceptionsMetadata(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionsMetadataResponse>> {
    const req = this.createRequest('GET', '/routingexception/metadata');
    return req.callAsXml(
      'TerminationRoutingExceptionsMetadataResponse',
      terminationRoutingExceptionsMetadataResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param id
   * @return Response from the API call
   */
  async getRoutingExceptionMetadata(
    id: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionMetadataResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, number()] });
    req.appendTemplatePath`/routingexception/metadata/${mapped.id}`;
    return req.callAsXml(
      'TerminationRoutingExceptionMetadataResponse',
      terminationRoutingExceptionMetadataResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param name
   * @return Response from the API call
   */
  async getRoutingExceptionsMetadataByNamePattern(
    name?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationRoutingExceptionsMetadataByNameResponse>> {
    const req = this.createRequest('GET', '/routingexception/metadata/search');
    const mapped = req.prepareArgs({ name: [name, optional(string())] });
    req.query('name', mapped.name);
    return req.callAsXml(
      'TerminationRoutingExceptionsMetadataByNameResponse',
      terminationRoutingExceptionsMetadataByNameResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param gatewayId
   * @return Response from the API call
   */
  async getGateway(
    accountId: number,
    gatewayId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewayResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      gatewayId: [gatewayId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/gateway/${mapped.gatewayId}`;
    return req.callAsXml(
      'TerminationGatewayResponse',
      terminationGatewayResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param gatewayId
   * @return Response from the API call
   */
  async deleteGateway(
    accountId: number,
    gatewayId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewayResponse>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      accountId: [accountId, number()],
      gatewayId: [gatewayId, number()],
    });
    req.appendTemplatePath`/account/${mapped.accountId}/gateway/${mapped.gatewayId}`;
    return req.callAsXml(
      'TerminationGatewayResponse',
      terminationGatewayResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @return Response from the API call
   */
  async getGateways(
    accountId: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewaysResponse>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.appendTemplatePath`/account/${mapped.accountId}/gateway`;
    return req.callAsXml(
      'TerminationGatewaysResponse',
      terminationGatewaysResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param accountId
   * @param body
   * @return Response from the API call
   */
  async postGateway(
    accountId: number,
    body?: TerminationGateway,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TerminationGatewayResponse>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ accountId: [accountId, number()] });
    req.xml(
      'body',
      body,
      'TerminationGateway',
      optional(terminationGatewaySchema)
    );
    req.appendTemplatePath`/account/${mapped.accountId}/gateway`;
    return req.callAsXml(
      'TerminationGatewayResponse',
      terminationGatewayResponseSchema,
      requestOptions
    );
  }

  /**
   * TODO
   *
   * @param id
   * @return Response from the API call
   */
  async getFile1(
    id: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({ id: [id, number()] });
    req.appendTemplatePath`/carriermask/${mapped.id}/file`;
    return req.callAsXml('response', unknown(), requestOptions);
  }
}
